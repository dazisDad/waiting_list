// webhook/notification.js
// Polls /webhook/last_event.json every 3 seconds and shows notification when changed.

// DOM elements and app loader are provided inline in index.html and exposed as globals:
// startBtn, stopBtn, eventsList, logEl, appSelect, loadApps

let pollTimer = null;
let lastText = null;
let swRegistration = null;
const POLL_INTERVAL = 3000; // ms

// Logging is done to the console only. UI log element is provided by index.html
// and can be updated there if needed.

async function registerSW() {
  console.log('registerSW: start');
  if ('serviceWorker' in navigator) {
    try {
      swRegistration = await navigator.serviceWorker.register('sw.js');
    console.log('ServiceWorker registered');
      console.log('registerSW: success', swRegistration);
    } catch (e) {
      addLog('ServiceWorker register failed: ' + e.message);
      console.log('registerSW: failed', e);
    }
  } else {
    console.log('registerSW: serviceWorker not supported');
    console.log('ServiceWorker not supported in this browser');
  }
}

async function ensureNotificationPermission() {
  if (!('Notification' in window)) {
  console.log('ensureNotificationPermission: Notification API not supported');
    return false;
  }
  console.log('ensureNotificationPermission: current permission=', Notification.permission);
  if (Notification.permission === 'granted') return true;
  const p = await Notification.requestPermission();
  console.log('ensureNotificationPermission: new permission=', p);
  return p === 'granted';
}

function showNotification(title, body) {
  console.log('showNotification:', title, body);
  if (swRegistration && swRegistration.showNotification) {
    try {
      swRegistration.showNotification(title, { body, icon: '' });
      console.log('showNotification: sent via service worker');
    } catch (e) {
      console.log('showNotification: service worker failed, fallback', e);
      // fallback
      if (Notification.permission === 'granted') new Notification(title, { body });
    }
  } else if (Notification.permission === 'granted') {
    new Notification(title, { body });
    console.log('showNotification: sent via Notification API');
  } else {
    addLog('Notification not permitted');
    console.log('showNotification: not permitted');
  }
}

function handleNewEvent(obj) {
  console.log('handleNewEvent: received', obj);
  const li = document.createElement('li');
  li.textContent = JSON.stringify(obj);
  // eventsList supplied by index.html
  if (window.eventsList) window.eventsList.insertBefore(li, window.eventsList.firstChild);

  const title = obj && obj.Id ? `Row ${obj.Id} changed` : 'Webhook update';
  const body = JSON.stringify(obj);
  showNotification(title, body);
}

async function pollOnce() {
  try {
    const file = (window.appSelect && window.appSelect.value) ? window.appSelect.value : 'last_event.json';
    console.log('pollOnce: fetching', file);
    const resp = await fetch(file, { cache: 'no-store' });
    if (!resp.ok) {
      console.log('pollOnce: fetch failed', resp.status);
      return;
    }
    // webhook/notification.js
    // Polls a selected webhook JSON file every 3 seconds and shows notification when changed.

    // DOM elements and app loader are provided inline in index.html and exposed as globals:
    // startBtn, stopBtn, eventsList, appSelect, loadApps

    let pollTimer = null;
    let lastText = null;
    let swRegistration = null;
    const POLL_INTERVAL = 3000; // ms

    // Logging is done to the console only. UI log element is provided by index.html
    // and can be updated there if needed.

    async function registerSW() {
      console.log('registerSW: start');
      if ('serviceWorker' in navigator) {
        try {
          swRegistration = await navigator.serviceWorker.register('sw.js');
          console.log('ServiceWorker registered');
          console.log('registerSW: success', swRegistration);
        } catch (e) {
          console.log('registerSW: failed', e);
        }
      } else {
        console.log('registerSW: serviceWorker not supported');
      }
    }

    async function ensureNotificationPermission() {
      if (!('Notification' in window)) {
        console.log('ensureNotificationPermission: Notification API not supported');
        return false;
      }
      console.log('ensureNotificationPermission: current permission=', Notification.permission);
      if (Notification.permission === 'granted') return true;
      const p = await Notification.requestPermission();
      console.log('ensureNotificationPermission: new permission=', p);
      return p === 'granted';
    }

    function showNotification(title, body) {
      console.log('showNotification:', title, body);
      if (swRegistration && swRegistration.showNotification) {
        try {
          swRegistration.showNotification(title, { body, icon: '' });
          console.log('showNotification: sent via service worker');
        } catch (e) {
          console.log('showNotification: service worker failed, fallback', e);
          // fallback
          if (Notification.permission === 'granted') new Notification(title, { body });
        }
      } else if (Notification.permission === 'granted') {
        new Notification(title, { body });
        console.log('showNotification: sent via Notification API');
      // webhook/notification.js
      // Polls a selected webhook JSON file every 3 seconds and shows notification when changed.

      // DOM elements and app loader are provided inline in index.html and exposed as globals:
      // startBtn, stopBtn, eventsList, appSelect, loadApps

      let pollTimer = null;
      let lastText = null;
      let swRegistration = null;
      const POLL_INTERVAL = 3000; // ms

      // Logging is done to the console only. UI log element is provided by index.html
      // and can be updated there if needed.

      async function registerSW() {
        console.log('registerSW: start');
        if ('serviceWorker' in navigator) {
          try {
            swRegistration = await navigator.serviceWorker.register('sw.js');
            console.log('ServiceWorker registered');
            console.log('registerSW: success', swRegistration);
          } catch (e) {
            console.log('registerSW: failed', e);
          }
        } else {
          console.log('registerSW: serviceWorker not supported');
        }
      }

      async function ensureNotificationPermission() {
        if (!('Notification' in window)) {
          console.log('ensureNotificationPermission: Notification API not supported');
          return false;
        }
        console.log('ensureNotificationPermission: current permission=', Notification.permission);
        if (Notification.permission === 'granted') return true;
        const p = await Notification.requestPermission();
        console.log('ensureNotificationPermission: new permission=', p);
        return p === 'granted';
      }

      function showNotification(title, body) {
        console.log('showNotification:', title, body);
        if (swRegistration && swRegistration.showNotification) {
          try {
            swRegistration.showNotification(title, { body, icon: '' });
            console.log('showNotification: sent via service worker');
          } catch (e) {
            console.log('showNotification: service worker failed, fallback', e);
            // fallback
            if (Notification.permission === 'granted') new Notification(title, { body });
          }
        } else if (Notification.permission === 'granted') {
          new Notification(title, { body });
          console.log('showNotification: sent via Notification API');
        // webhook/notification.js
        // Polls a selected webhook JSON file every 3 seconds and shows notification when changed.

        // DOM elements and app loader are provided inline in index.html and exposed as globals:
        // startBtn, stopBtn, eventsList, appSelect, loadApps

        let pollTimer = null;
        let lastText = null;
        let swRegistration = null;
        const POLL_INTERVAL = 3000; // ms

        // Logging is done to the console only. UI log element is provided by index.html
        // and can be updated there if needed.

        async function registerSW() {
          console.log('registerSW: start');
          if ('serviceWorker' in navigator) {
            try {
              swRegistration = await navigator.serviceWorker.register('sw.js');
              console.log('ServiceWorker registered');
              console.log('registerSW: success', swRegistration);
            } catch (e) {
              console.log('registerSW: failed', e);
            }
          } else {
            console.log('registerSW: serviceWorker not supported');
          }
        }

        async function ensureNotificationPermission() {
          if (!('Notification' in window)) {
            console.log('ensureNotificationPermission: Notification API not supported');
            return false;
          }
          console.log('ensureNotificationPermission: current permission=', Notification.permission);
          if (Notification.permission === 'granted') return true;
          const p = await Notification.requestPermission();
          console.log('ensureNotificationPermission: new permission=', p);
          return p === 'granted';
        }

        function showNotification(title, body) {
          console.log('showNotification:', title, body);
          if (swRegistration && swRegistration.showNotification) {
            try {
              swRegistration.showNotification(title, { body, icon: '' });
              console.log('showNotification: sent via service worker');
            } catch (e) {
              console.log('showNotification: service worker failed, fallback', e);
              // fallback
              if (Notification.permission === 'granted') new Notification(title, { body });
            }
          } else if (Notification.permission === 'granted') {
            new Notification(title, { body });
            console.log('showNotification: sent via Notification API');
          } else {
            console.log('showNotification: not permitted');
          }
        }

        function handleNewEvent(obj) {
          console.log('handleNewEvent: received', obj);
          const li = document.createElement('li');
          li.textContent = JSON.stringify(obj);
          // eventsList supplied by index.html
          if (window.eventsList) window.eventsList.insertBefore(li, window.eventsList.firstChild);

          const title = obj && obj.Id ? `Row ${obj.Id} changed` : 'Webhook update';
          const body = JSON.stringify(obj);
          showNotification(title, body);
        }

        async function pollOnce() {
          try {
            const file = (window.appSelect && window.appSelect.value) ? window.appSelect.value : 'last_event.json';
            console.log('pollOnce: fetching', file);
            const resp = await fetch(file, { cache: 'no-store' });
            if (!resp.ok) {
              console.log('pollOnce: fetch failed', resp.status);
              return;
            }
            const text = await resp.text();
            if (!text) return;

            // avoid parsing if identical
            if (text !== lastText) {
              lastText = text;
              try {
                const obj = JSON.parse(text);
                console.log('pollOnce: parsed JSON', obj);
                handleNewEvent(obj);
              } catch (e) {
                console.log('pollOnce: JSON parse error', e);
              }
            }
          } catch (e) {
            console.log('pollOnce: error', e);
          }
        }

        function startPolling() {
          if (pollTimer) return;
          pollOnce();
          pollTimer = setInterval(pollOnce, POLL_INTERVAL);
          startBtn.disabled = true;
          stopBtn.disabled = false;
          console.log('startPolling: interval set, every', POLL_INTERVAL);
        }

        function stopPolling() {
          if (!pollTimer) return;
          clearInterval(pollTimer);
          pollTimer = null;
          startBtn.disabled = false;
          stopBtn.disabled = true;
          console.log('stopPolling: stopped');
        }

        startBtn.addEventListener('click', async () => {
          await registerSW();
          const ok = await ensureNotificationPermission();
          if (!ok) {
            console.log('Notification permission not granted');
          }
          startPolling();
        });
        console.log('notification.js loaded');

        // app list loader is invoked from index.html on page load

        stopBtn.addEventListener('click', stopPolling);

        // Auto-start if desired (commented out)
        // (async () => { await registerSW(); await ensureNotificationPermission(); startPolling(); })();
