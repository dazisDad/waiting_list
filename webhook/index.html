<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Webhook Monitor</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:16px}
    #log{white-space:pre-wrap;margin-top:8px}
    ul{padding-left:20px}
    button{margin-right:8px}
  </style>
</head>
<body>
  <h3>Webhook Monitor</h3>
  <p>이 페이지는 <code>/webhook/last_event.json</code> 를 주기 폴링하여 변경을 감지합니다.</p>
  <div>
  <label for="appSelect">App:</label>
  <select id="appSelect"></select>
  </div>

  <ul id="events"></ul>
  <div id="log"></div>

  <script>
  // Bind DOM elements to globals so notification.js can use them
    window.eventsList = document.getElementById('events');
    window.logEl = document.getElementById('log');
    window.appSelect = document.getElementById('appSelect');

    // loadApps moved here from notification.js
    async function loadApps() {
      try {
        const resp = await fetch('list_apps.php', { cache: 'no-store' });
        if (!resp.ok) {
          const t = new Date().toLocaleString();
          window.logEl.textContent += `[${t}] Failed to load apps: ${resp.status}\n`;
          return;
        }
        const arr = await resp.json();
        // remember previous selection (if any) so we don't override user's choice
        const prev = window.appSelect && window.appSelect.value ? window.appSelect.value : null;
        // clear
        window.appSelect.innerHTML = '';
        const filenames = arr.map(a => a.filename);
        // choose a sensible default file: prefer waitlist app if present, then webhook_last_event_events.json, then last_event.json, else first available
        let defaultFile = 'last_event.json';
        // prefer explicit waitlist app
        if (filenames.includes('webhook_waitlist_events.json')) {
          defaultFile = 'webhook_waitlist_events.json';
        } else if (filenames.includes('waitlist.json')) {
          defaultFile = 'waitlist.json';
        } else if (filenames.includes('webhook_last_event_events.json')) {
          defaultFile = 'webhook_last_event_events.json';
        } else if (filenames.includes('last_event.json')) {
          defaultFile = 'last_event.json';
        } else if (filenames.length > 0) {
          defaultFile = filenames[0];
        }

        // add default option
        const def = document.createElement('option');
        def.value = defaultFile;
        def.textContent = defaultFile + ' (default)';
        window.appSelect.appendChild(def);

        arr.forEach(a => {
          if (a.filename === defaultFile) return; // already added
          const opt = document.createElement('option');
          opt.value = a.filename;
          opt.textContent = a.key + ' (' + a.filename + ')';
          window.appSelect.appendChild(opt);
        });

        // Try to preserve previous selection if still available
        if (prev && filenames.includes(prev)) {
          window.appSelect.value = prev;
        } else {
          window.appSelect.value = defaultFile;
        }
      } catch (e) {
        const t = new Date().toLocaleString();
        window.logEl.textContent += `[${t}] Error loading apps: ${e.message}\n`;
      }
    }

    // Expose loadApps globally
    window.loadApps = loadApps;

    // load apps immediately on page load
    (async () => { await loadApps(); })();
  </script>

  <script src="notification.js"></script>
  <script>
    (async () => {
      // Wait briefly for loadApps() to complete populating options (it runs on page load)
      for (let i = 0; i < 20; i++) {
        if (window.appSelect && window.appSelect.options && window.appSelect.options.length > 0) break;
        await new Promise(r => setTimeout(r, 100));
      }

      // Prefer a waitlist-named file if available
      const opts = Array.from(window.appSelect.options).map(o => o.value);
      let wanted = 'webhook_waitlist_events.json';
      if (!opts.includes(wanted)) {
        wanted = 'waitlist.json';
        if (!opts.includes(wanted)) {
          const found = opts.find(v => v.includes('waitlist'));
          if (found) wanted = found; else wanted = window.appSelect.value;
        }
      }
      try { window.appSelect.value = wanted; } catch (e) { console.log('select set failed', e); }

      // When the user changes the selected app, stop current polling and start polling the new one immediately
      window.appSelect.addEventListener('change', async () => {
        console.log('appSelect change ->', window.appSelect.value);
        if (typeof stopPolling === 'function') stopPolling();
        if (typeof registerSW === 'function') await registerSW();
        if (typeof ensureNotificationPermission === 'function') await ensureNotificationPermission();
        if (typeof startPolling === 'function') startPolling();
      });

      // Start polling now for the chosen default
      if (typeof registerSW === 'function') await registerSW();
      if (typeof ensureNotificationPermission === 'function') await ensureNotificationPermission();
      if (typeof startPolling === 'function') startPolling();
    })();
  </script>
</body>
</html>