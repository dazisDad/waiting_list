<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DL Waitlist Manager</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght400;600;700&display=swap" rel="stylesheet">
  <style>
    /* Inter font application and base style - Dark Modern Theme */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #0f172a;
      color: #e2e8f0;
    }

    /* Status Colors for Icon - Neon effect for dark theme */
    .status-waiting {
      color: #fbbf24;
      text-shadow: 0 0 8px rgba(251, 191, 36, 0.5);
    }

    .status-called {
      color: #fb923c;
      text-shadow: 0 0 8px rgba(251, 146, 60, 0.5);
    }

    .status-checkedin {
      color: #8b5cf6;
      text-shadow: 0 0 8px rgba(139, 92, 246, 0.5);
    }

    .status-cancelled {
      color: #f87171;
      text-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
    }

    /* Dark Modern Button Styles */
    .action-button {
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }

    .action-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px -4px rgba(0, 0, 0, 0.4);
    }

    /* Desktop: Remove all button hover/active background effects - only row highlights */
    @media (min-width: 769px) {
      .action-button {
        transition: none !important;
      }
      
      .action-button:hover:not(:disabled) {
        transform: none !important;
        box-shadow: none !important;
      }
    }

    /* Outline button styles - Ready */
    .btn-ready {
      background-color: transparent;
      border-color: #34d399;
      color: #34d399;
    }

    /* Outline button styles - Ask */
    .btn-ask {
      background-color: transparent;
      border-color: #60a5fa;
      color: #60a5fa;
    }

    /* Outline button styles - Arrive */
    .btn-arrive {
      background-color: transparent;
      border-color: #8b5cf6;
      color: #8b5cf6;
    }

    /* Outline button styles - Cancel (Danger) */
    .btn-cancel {
      background-color: transparent;
      border-color: #f87171;
      color: #f87171;
    }

    /* Outline button styles - Undo */
    .btn-undo {
      background-color: transparent;
      border-color: #fbbf24;
      color: #fbbf24;
    }

    /* Disabled button state */
    .action-button:disabled {
      background-color: #475569;
      border-color: #475569;
      color: #94a3b8;
      cursor: not-allowed;
      opacity: 0.6;
    }

    /* Highlight animation for completed items - Dark theme */
    .arrive-highlight {
      background-color: rgba(139, 92, 246, 0.15) !important;
      box-shadow: none !important;
      border: none !important;
      transition: all 0.3s ease-in-out;
    }

    .cancel-highlight {
      background-color: rgba(248, 113, 113, 0.15) !important;
      box-shadow: none !important;
      border: none !important;
      transition: all 0.3s ease-in-out;
    }

    .fade-out-highlight {
      background-color: transparent !important;
      box-shadow: none;
      transition: all 0.7s ease-out;
    }

    /* Button click highlight - brief flash effect */
    tbody tr.button-click-highlight,
    tbody tr.button-click-highlight:hover,
    tbody tr.row-hover.button-click-highlight,
    tbody tr.row-hover.button-click-highlight:hover,
    tbody tr.bg-slate-900.button-click-highlight,
    tbody tr.bg-slate-900.button-click-highlight:hover {
      background-color: #334155 !important;
      transition: none !important;
    }
    
    /* Override any conflicting background colors */
    .button-click-highlight.bg-slate-900 {
      background-color: #334155 !important;
    }

    /* Persistent row highlight (toggle on/off by clicking row) */
    tbody tr.row-persistent-highlight,
    tbody tr.row-persistent-highlight:hover,
    tbody tr.row-hover.row-persistent-highlight,
    tbody tr.row-hover.row-persistent-highlight:hover,
    tbody tr.bg-slate-900.row-persistent-highlight,
    tbody tr.bg-slate-900.row-persistent-highlight:hover {
      background-color: #334155 !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    /* Row hover effect */
    .row-hover:hover {
      background-color: #334155 !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    /* Completed row style */
    .row-completed {
      background-color: #1e293b;
    }
    .row-completed:hover {
      background-color: #334155 !important;
    }

    /* Disable hover during scroll to prevent unwanted highlights */
    .disable-hover .row-hover:hover,
    .disable-hover .row-completed:hover {
      background-color: inherit !important;
      box-shadow: none !important;
    }

    /* Desktop: Ensure row-selected has no effect */
    @media (min-width: 769px) {
      .row-selected {
        background-color: inherit !important;
        border-left: none !important;
        box-shadow: none !important;
      }

      /* Remove focus styles from rows on desktop */
      .row-clickable,
      .row-hover,
      .row-completed,
      tr {
        outline: none !important;
      }

      .row-clickable:focus,
      .row-clickable:focus-visible,
      .row-clickable:focus-within,
      .row-hover:focus,
      .row-hover:focus-visible,
      .row-hover:focus-within,
      .row-completed:focus,
      .row-completed:focus-visible,
      .row-completed:focus-within,
      tr:focus,
      tr:focus-visible,
      tr:focus-within {
        outline: none !important;
        background-color: inherit !important;
        box-shadow: none !important;
      }

      /* Disable pointer events on row onclick for desktop */
      .row-clickable {
        pointer-events: auto;
        cursor: default !important;
      }
    }

    /* Mobile: Hide Action column header and cells */
    @media (max-width: 768px) {
      .action-column-header,
      .action-column-cell {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }

      /* Mobile row cursor */
      .row-clickable {
        cursor: pointer;
        transition: none !important;
      }

      /* Make only the row itself clickable, not its children */
      .row-clickable > td {
        pointer-events: auto;
      }

      .row-clickable > td > * {
        pointer-events: none !important;
      }

      /* Disable all button interactions on mobile (buttons are hidden anyway) */
      .action-column-cell button,
      .action-column-cell .action-button {
        pointer-events: none !important;
        transition: none !important;
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }

      /* Force disable all button states on mobile */
      .action-column-cell .btn-ask,
      .action-column-cell .btn-ask:hover,
      .action-column-cell .btn-ask:active,
      .action-column-cell .btn-ask:focus,
      .action-column-cell .btn-ask:focus-visible {
        background-color: transparent !important;
        transition: none !important;
        pointer-events: none !important;
      }

      .action-column-cell .btn-ready,
      .action-column-cell .btn-ready:hover,
      .action-column-cell .btn-ready:active,
      .action-column-cell .btn-ready:focus,
      .action-column-cell .btn-ready:focus-visible {
        background-color: transparent !important;
        transition: none !important;
        pointer-events: none !important;
      }

      .action-column-cell .btn-cancel,
      .action-column-cell .btn-cancel:hover,
      .action-column-cell .btn-cancel:active,
      .action-column-cell .btn-cancel:focus,
      .action-column-cell .btn-cancel:focus-visible {
        background-color: transparent !important;
        transition: none !important;
        pointer-events: none !important;
      }

      .action-column-cell .btn-arrive,
      .action-column-cell .btn-arrive:hover,
      .action-column-cell .btn-arrive:active,
      .action-column-cell .btn-arrive:focus,
      .action-column-cell .btn-arrive:focus-visible {
        background-color: #8b5cf6 !important;
        transition: none !important;
        pointer-events: none !important;
      }

      /* Disable hover effect on mobile to avoid confusion */
      .row-hover,
      .row-completed {
        transition: none !important;
      }

      .row-hover:hover,
      .row-completed:hover {
        background-color: inherit !important;
        box-shadow: none !important;
        transition: none !important;
      }

      /* Selected row highlight on mobile - No transition for instant feedback */
      .row-selected {
        background-color: #334155 !important;
        border-left: 3px solid #8b5cf6 !important;
        transition: none !important;
      }

      .row-selected:hover {
        background-color: #334155 !important;
        box-shadow: none !important;
      }

      /* Expanded row for mobile buttons */
      .mobile-action-row {
        background-color: #1e293b;
        border-top: 1px solid #475569;
      }

      .mobile-action-row td {
        padding: 12px 8px;
      }

      /* Mobile button styles - No transition for instant feedback */
      .mobile-btn,
      .mobile-btn-call,
      .mobile-btn-ask,
      .mobile-btn-checkin,
      .mobile-btn-cancel {
        transition: none !important;
      }

      /* Mobile Ready button */
      .mobile-btn-ready {
        background-color: transparent;
        border: 1px solid #34d399;
        color: #34d399;
      }
      .mobile-btn-ready:active {
        background-color: #34d399;
        color: #ffffff;
        transition: none !important;
      }

      /* Mobile Ask button */
      .mobile-btn-ask {
        background-color: transparent;
        border: 1px solid #60a5fa;
        color: #60a5fa;
      }
      .mobile-btn-ask:active {
        background-color: #60a5fa;
        color: #ffffff;
        transition: none !important;
      }

      /* Mobile Arrive button */
      .mobile-btn-arrive {
        background-color: transparent;
        border: 1px solid #8b5cf6;
        color: #8b5cf6;
      }
      .mobile-btn-arrive:active {
        background-color: #8b5cf6;
        color: #ffffff;
        transition: none !important;
      }

      /* Mobile Cancel button */
      .mobile-btn-cancel {
        background-color: transparent;
        border: 1px solid #f87171;
        color: #f87171;
      }
      .mobile-btn-cancel:active {
        background-color: #f87171;
        color: #ffffff;
        transition: none !important;
      }

      /* Mobile Undo button */
      .mobile-btn-undo {
        background-color: transparent;
        border: 1px solid #fbbf24;
        color: #fbbf24;
      }
      .mobile-btn-undo:active {
        background-color: #fbbf24;
        color: #ffffff;
        transition: none !important;
      }

      /* Adjust table widths for mobile */
      .mobile-adjusted-width {
        width: auto !important;
      }
    }

    /* Desktop: Hide mobile action rows */
    @media (min-width: 769px) {
      .mobile-action-row {
        display: none !important;
      }
    }
  </style>
</head>

<body class="p-4 sm:p-8">
  <!-- Dark Modern container -->
  <div class="max-w-5xl mx-auto bg-slate-800 rounded-xl shadow-2xl p-4 sm:p-6 border border-slate-700">
    <header class="mb-6 border-b border-slate-600 pb-3">
      <h1 class="text-3xl sm:text-4xl font-extrabold text-slate-100 flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
          class="w-8 h-8 text-violet-400 mr-3">
          <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
          <circle cx="12" cy="7" r="4" />
          <path d="M2 22h20" />
          <path d="M2 17h20" />
        </svg>
        Waitlist Management System
      </h1>
      <p class="text-slate-400 mt-1">Real-time queue status and customer service management</p>
    </header>

    <!-- Scroll to Active Button -->
    <div class="mb-4 flex justify-end">
      <!-- Button calls the unified scroll handler -->
      <!-- Initial state is disabled, the logic will update the text and class -->
      <button id="scroll-to-active-btn" onclick="handleScrollToActive()" disabled
        class="action-button px-4 py-2 text-sm font-semibold rounded-lg transition duration-150 bg-slate-700 text-slate-500 cursor-not-allowed border border-slate-600">
        @ Active Queue
      </button>
    </div>

    <!-- Waitlist Table -->
    <!-- Outer div maintains shadow and horizontal scroll for narrow screens -->
    <div class="shadow-2xl rounded-lg overflow-x-auto border border-slate-700">
      <!-- Inner container for vertical scrolling with fixed header -->
      <div id="waitlist-container" class="max-h-[60vh] overflow-y-auto relative bg-slate-900">
        <table class="min-w-full divide-y divide-slate-700">
          <thead class="bg-slate-800 sticky top-0 z-10 border-b border-slate-700">
            <tr>
              <!-- Reduced padding (px-2 py-2) and centered -->
              <th class="px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-[6%]">No.
              </th>
              <!-- Increased width for Name column to accommodate chat history -->
              <th class="px-2 py-2 text-left text-xs font-semibold text-slate-300 uppercase tracking-wider w-[32%]">Name
              </th>
              <!-- Minimized width for Pax -->
              <th class="px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-[5%]">Pax
              </th>
              <!-- Minimized width for Elapsed Time -->
              <th class="px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-[12%]">
                Elapsed</th>
              <!-- Adjusted width for Action column - Hidden on mobile -->
              <th class="action-column-header px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-[45%]">
                Action</th>
            </tr>
          </thead>
          <tbody id="waitlist-body" class="bg-slate-900 divide-y divide-slate-800">
            <!-- Data will be injected here by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>

    <footer class="mt-6 text-center text-slate-500 text-sm">
      <p>Data is generated as a mockup; production environments use Firestore.</p>
    </footer>
  </div>

  <!-- Message Box for Alerts (replacing alert()) - Dark theme -->
  <div id="message-box" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4 z-50">
    <div class="bg-slate-800 p-6 rounded-lg shadow-2xl max-w-sm w-full border border-slate-700">
      <h3 class="text-lg font-bold text-slate-100 mb-4">Notification</h3>
      <p id="message-text" class="text-slate-300 mb-6"></p>
      <div class="text-right">
        <button onclick="closeMessageBox()"
          class="px-4 py-2 bg-violet-600 text-white rounded-md hover:bg-violet-700 transition duration-150 action-button border-0">
          Close
        </button>
      </div>
    </div>
  </div>

  <script>
    // Create mock waitlist data based on current time
    // Extended list for testing minRowDisplay functionality
    const mockWaitlist = [
      // Completed items (will be sorted to the top) - with time_cleared set
      { booking_number: 1005, customer_name: "Haneul Jung", pax: 2, time_created: Date.now() - 45 * 60 * 1000, time_cleared: Date.now() - 40 * 60 * 1000, status: "Cancelled", booking_list_id: "123", customer_phone: "010-1111-1111", subscriber_id: "sub_aaa" },
      { booking_number: 1008, customer_name: "Jimin Lee", pax: 3, time_created: Date.now() - 50 * 60 * 1000, time_cleared: Date.now() - 45 * 60 * 1000, status: "Arrived", booking_list_id: "234", customer_phone: "010-2222-2222", subscriber_id: "sub_bbb" },
      { booking_number: 1010, customer_name: "Yuna Choi", pax: 4, time_created: Date.now() - 55 * 60 * 1000, time_cleared: null, status: "Waiting", booking_list_id: "456", customer_phone: "010-3333-3333", subscriber_id: "sub_ccc" },

      // Active items (Waiting/Ready) - no time_cleared
      { booking_number: 1001, customer_name: "Minji Kim", pax: 4, time_created: Date.now() - 35 * 60 * 1000, time_cleared: null, status: "Waiting", booking_list_id: "235", customer_phone: "010-4444-4444", subscriber_id: "sub_ddd" },
      { booking_number: 1002, customer_name: "Juno Lee", pax: 2, time_created: Date.now() - 30 * 60 * 1000, time_cleared: null, status: "Waiting", booking_list_id: "335", customer_phone: "010-5555-5555", subscriber_id: "sub_eee" },
      { booking_number: 1003, customer_name: "Seyeon Park", pax: 3, time_created: Date.now() - 25 * 60 * 1000, time_cleared: null, status: "Ready", booking_list_id: "347", customer_phone: "010-6666-6666", subscriber_id: "sub_fff" },
      { booking_number: 1004, customer_name: "Eunwoo Choi", pax: 5, time_created: Date.now() - 20 * 60 * 1000, time_cleared: null, status: "Waiting", booking_list_id: "156", customer_phone: "010-7777-7777", subscriber_id: "sub_ggg" },
      { booking_number: 1006, customer_name: "Jihoon Kim", pax: 3, time_created: Date.now() - 15 * 60 * 1000, time_cleared: null, status: "Waiting", booking_list_id: "287", customer_phone: "010-8888-8888", subscriber_id: "sub_hhh" },
      { booking_number: 1007, customer_name: "Somin Park", pax: 6, time_created: Date.now() - 10 * 60 * 1000, time_cleared: null, status: "Waiting", booking_list_id: "563", customer_phone: "010-9999-9999", subscriber_id: "sub_iii" },
      { booking_number: 1009, customer_name: "Taehyun Lee", pax: 2, time_created: Date.now() - 5 * 60 * 1000, time_cleared: null, status: "Waiting", booking_list_id: "763", customer_phone: "010-0000-0000", subscriber_id: "sub_jjj" },
    ];

    const mockChatList = [
      { Id: 1, booking_list_id: "123", dateTime: Date.now() - 45 * 60 * 1000, qna: "Waiting" },
      { Id: 2, booking_list_id: "234", dateTime: Date.now() - 50 * 60 * 1000, qna: "Waiting" },
      { Id: 3, booking_list_id: "456", dateTime: Date.now() - 55 * 60 * 1000, qna: "Waiting" },
      
      { Id: 4, booking_list_id: "235", dateTime: Date.now() - 35 * 60 * 1000, qna: "Waiting" },
      { Id: 5, booking_list_id: "335", dateTime: Date.now() - 30 * 60 * 1000, qna: "Waiting" },
      { Id: 6, booking_list_id: "347", dateTime: Date.now() - 25 * 60 * 1000, qna: "Waiting" },

      { Id: 7, booking_list_id: "335", dateTime: Date.now() - 23 * 60 * 1000, qna: "Q: Table is Ready. Coming?" },
      { Id: 8, booking_list_id: "335", dateTime: Date.now() - 22 * 60 * 1000, qna: "A: Coming in 5 mins" },

      { Id: 9, booking_list_id: "156", dateTime: Date.now() - 20 * 60 * 1000, qna: "Waiting" },
      { Id: 10, booking_list_id: "287", dateTime: Date.now() - 15 * 60 * 1000, qna: "Waiting" },
      { Id: 11, booking_list_id: "563", dateTime: Date.now() - 10 * 60 * 1000, qna: "Waiting" },
      { Id: 12, booking_list_id: "763", dateTime: Date.now() - 5 * 60 * 1000, qna: "Waiting" },
    ];

    const waitlistBody = document.getElementById('waitlist-body');
    const messageBox = document.getElementById('message-box');
    const messageText = document.getElementById('message-text');
    const scrollButton = document.getElementById('scroll-to-active-btn');
    const waitlistContainer = document.getElementById('waitlist-container');

    // Define the Tailwind class for maximum height
    const MAX_HEIGHT_CLASS = 'max-h-[60vh]';

    // Number of rows to display on screen (including completed items)
    const displayedRows = 7;

    // --- Global State Variables ---
    let isInitialScrollDone = false;
    let initialScrollTop = 0; // 초기 스크롤 탑 값 저장 변수 (Active Queue의 시작 위치를 추적)
    let rowHeight = 0; // 단일 행의 높이 (Check-In/Cancel 시 initialScrollTop 업데이트에 사용)
    let expandedRowId = null; // 현재 확장된 행의 ID (모바일용)

    // --- Action Button Definitions ---
    const actionButtonDefinitions = [
      {
        id: 'ready',
        label: 'Ready',
        color: '#34d399', // green
        textColor: '#34d399',
        isBackgroundFill: false,
        functionName: 'handleReady',
        showForStatus: ['Waiting', 'Ready'], // Show for these statuses
        mobileBtnClass: 'mobile-btn-ready',
        desktopBtnClass: 'btn-ready'
      },
      {
        id: 'ask',
        label: 'Ask',
        color: '#60a5fa', // blue
        textColor: '#60a5fa',
        isBackgroundFill: false,
        functionName: 'handleAsk',
        showForStatus: ['Waiting', 'Ready'],
        mobileBtnClass: 'mobile-btn-ask',
        desktopBtnClass: 'btn-ask'
      },
      {
        id: 'arrive',
        label: 'Arrive',
        color: '#8b5cf6', // purple
        textColor: '#8b5cf6', // purple text for outline style
        isBackgroundFill: false,
        functionName: 'handleArrive',
        showForStatus: ['Waiting', 'Ready'],
        mobileBtnClass: 'mobile-btn-arrive',
        desktopBtnClass: 'btn-arrive'
      },
      {
        id: 'cancel',
        label: 'Cancel',
        color: '#f87171', // red
        textColor: '#f87171',
        isBackgroundFill: false,
        functionName: 'handleCancel',
        showForStatus: ['Waiting', 'Ready'],
        mobileBtnClass: 'mobile-btn-cancel',
        desktopBtnClass: 'btn-cancel'
      },
      {
        id: 'undo',
        label: 'Undo',
        color: '#fbbf24', // yellow/amber
        textColor: '#fbbf24',
        isBackgroundFill: false,
        functionName: 'handleUndo',
        showForStatus: ['Arrived', 'Cancelled'],
        mobileBtnClass: 'mobile-btn-undo',
        desktopBtnClass: 'btn-undo'
      }
    ];

    /**
     * Helper function to get buttons for a specific item status
     */
    function getButtonsForStatus(status) {
      return actionButtonDefinitions.filter(btn => btn.showForStatus.includes(status));
    }

    /**
     * Helper function to generate button HTML
     */
    function generateButtonHTML(buttonDef, booking_number, customer_name, isMobile) {
      const baseClasses = 'action-button px-3 py-1.5 rounded-md border font-medium text-sm';
      const btnClass = isMobile ? buttonDef.mobileBtnClass : buttonDef.desktopBtnClass;
      const classes = `${baseClasses} ${btnClass} flex-1`;
      
      // Determine if event parameter is needed
      const needsEvent = ['handleReady', 'handleAsk'].includes(buttonDef.functionName);
      const fnCall = needsEvent 
        ? `${buttonDef.functionName}(${booking_number}, '${customer_name}', event)`
        : `${buttonDef.functionName}(${booking_number}, '${customer_name}')`;
      
      // Add blur on click to remove focus highlight (desktop only)
      const onclickHandler = isMobile 
        ? `${fnCall}` 
        : `${fnCall}; setTimeout(() => this.blur(), 100);`;
      
      return `<button onclick="${onclickHandler}" class="${classes}">${buttonDef.label}</button>`;
    }

    /**
     * Mobile: Toggle mobile action row for a specific item
     * Desktop: Toggle row highlight
     */
    function toggleMobileActions(booking_number, event) {
      // Check if we're on mobile (screen width <= 768px)
      if (window.innerWidth > 768) {
        // Desktop: Toggle row highlight (persistent)
        if (event) {
          // If the click originated from a button, ignore it
          if (event.target.tagName === 'BUTTON' || event.target.closest('button')) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
        }
        
        // Toggle persistent highlight on the row
        highlightRow(booking_number, false);
        console.log(`DESKTOP: Toggled highlight for row #${booking_number}`);
        return;
      }

      // Mobile functionality (rest of the code remains the same)
      // Prevent event bubbling and default behavior
      if (event) {
        // If the click originated from a button, ignore it (shouldn't happen on mobile but safety check)
        if (event.target.tagName === 'BUTTON' || event.target.closest('button')) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
      }

      const mobileActionRowId = `mobile-actions-${booking_number}`;
      const existingMobileRow = document.getElementById(mobileActionRowId);
      const currentRow = document.querySelector(`tr[data-item-id="${booking_number}"]`);

      // If clicking the same row, close it
      if (expandedRowId === booking_number) {
        if (existingMobileRow) {
          existingMobileRow.remove();
        }
        if (currentRow) {
          // Force immediate class removal
          currentRow.classList.remove('row-selected');
          // Force reflow to ensure immediate visual update
          void currentRow.offsetHeight;
        }
        expandedRowId = null;
        console.log(`MOBILE: Collapsed row for item #${booking_number}`);
        return;
      }

      // If another row is expanded, close it first
      if (expandedRowId !== null) {
        const prevMobileRow = document.getElementById(`mobile-actions-${expandedRowId}`);
        if (prevMobileRow) {
          prevMobileRow.remove();
        }
        const prevRow = document.querySelector(`tr[data-item-id="${expandedRowId}"]`);
        if (prevRow) {
          prevRow.classList.remove('row-selected');
          // Force reflow
          void prevRow.offsetHeight;
        }
      }

      // Add highlight to the newly selected row immediately
      if (currentRow) {
        // Force reflow before adding class to ensure clean state
        void currentRow.offsetHeight;
        currentRow.classList.add('row-selected');
        // Force another reflow to ensure immediate application
        void currentRow.offsetHeight;
      }

      // Expand the clicked row
      expandedRowId = booking_number;
      const item = mockWaitlist.find(i => i.booking_number === booking_number);
      if (!item) return;

      // Get buttons for this item's status
      const buttons = getButtonsForStatus(item.status);
      const buttonHTMLs = buttons.map(btnDef => generateButtonHTML(btnDef, item.booking_number, item.customer_name, true));
      const actionButtons = buttonHTMLs.join('\n');

      // Find the main row and insert mobile action row after it
      const mainRow = document.querySelector(`tr[data-item-id="${booking_number}"]`);
      if (mainRow) {
        const mobileRow = document.createElement('tr');
        mobileRow.id = mobileActionRowId;
        mobileRow.className = 'mobile-action-row';
        mobileRow.innerHTML = `
          <td colspan="5" class="px-2 py-3">
            <div class="flex gap-1.5">
              ${actionButtons}
            </div>
          </td>
        `;
        
        // Insert after the main row
        mainRow.insertAdjacentElement('afterend', mobileRow);
        console.log(`MOBILE: Expanded row for item #${booking_number}`);
      }
    }

    /**
     * For completed items (Check-In/Cancelled), returns object with completion time and duration.
     * For active items (Waiting/Called), shows current elapsed time from time_created.
     */
    function formatElapsedTime(item) {
      if (item.time_cleared) {
        // Completed items - return completion time and duration separately for two-line display
        const completionTime = new Date(item.time_cleared);
        const timeString = completionTime.toLocaleTimeString('en-GB', {
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });

        // Calculate duration
        const durationMs = item.time_cleared - item.time_created;
        const totalSeconds = Math.floor(durationMs / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        let durationString;
        if (minutes >= 60) {
          const hours = Math.floor(minutes / 60);
          const remainingMinutes = minutes % 60;
          if (remainingMinutes > 0) {
            durationString = `${hours} hr ${remainingMinutes} min`;
          } else {
            durationString = `${hours} hr`;
          }
        } else if (minutes > 0) {
          durationString = `${minutes} min`;
        } else {
          durationString = `${seconds} sec`;
        }

        return { time: timeString, duration: durationString, isTwoLine: true };
      } else {
        // Active items - calculate current elapsed time
        const elapsedMs = Date.now() - item.time_created;
        const totalSeconds = Math.floor(elapsedMs / 1000);

        let minutes = Math.floor(totalSeconds / 60);
        const seconds = String(totalSeconds % 60).padStart(2, '0');

        let displayString;
        if (minutes >= 60) {
          const hours = Math.floor(minutes / 60);
          const remainingMinutes = String(minutes % 60).padStart(2, '0');
          displayString = `${hours}:${remainingMinutes}:${seconds}`;
        } else {
          displayString = `${minutes}:${seconds}`;
        }

        return { time: displayString, duration: '', isTwoLine: false };
      }
    }

    /**
     * Returns the appropriate icon and CSS class based on the status string.
     */
    function getStatusIconAndClass(status) {
      let icon = '';
      let className = 'text-2xl font-bold';

      switch (status) {
        case 'Waiting':
        case 'Ready':
          icon = '◎';
          className += ' status-waiting';
          break;
        case 'Arrived':
          icon = '✔';
          className += ' status-checkedin';
          break;
        case 'Cancelled':
          icon = '✗';
          className += ' status-cancelled';
          break;
        default:
          icon = '❔';
          className += ' text-gray-500';
      }
      return { icon, className };
    }

    /**
     * Displays a message box (replacing alert()).
     */
    function showMessageBox(message) {
      messageText.textContent = message;
      messageBox.classList.remove('hidden');
      messageBox.classList.add('flex');
    }

    /**
     * Closes the message box.
     */
    function closeMessageBox() {
      messageBox.classList.add('hidden');
      messageBox.classList.remove('flex');
    }

    /**
     * Adds a temporary highlight effect to a row.
     * The highlight appears briefly and then fades out.
     */
    function highlightRow(booking_number, shouldFlash = false) {
      requestAnimationFrame(() => {
        const rows = waitlistBody.getElementsByTagName('tr');
        const targetRow = Array.from(rows).find(row => {
          const idCell = row.querySelector('td:first-child');
          return idCell && idCell.textContent.trim() === booking_number.toString();
        });

        if (targetRow) {
          if (shouldFlash) {
            // Flash effect: temporary highlight that disappears
            const originalBgColor = targetRow.style.backgroundColor;
            
            targetRow.classList.add('button-click-highlight');
            targetRow.style.backgroundColor = '#334155';
            
            setTimeout(() => {
              targetRow.classList.remove('button-click-highlight');
              targetRow.style.backgroundColor = originalBgColor;
            }, 500);
          } else {
            // Toggle persistent highlight
            const isCurrentlyHighlighted = targetRow.classList.contains('row-persistent-highlight');
            
            // First, remove highlight from all other rows
            const allRows = waitlistBody.getElementsByTagName('tr');
            Array.from(allRows).forEach(row => {
              if (row !== targetRow) {
                row.classList.remove('row-persistent-highlight');
                // Remove inline style completely
                row.style.removeProperty('background-color');
              }
            });
            
            if (isCurrentlyHighlighted) {
              // Remove highlight from this row
              targetRow.classList.remove('row-persistent-highlight');
              // Remove inline style completely
              targetRow.style.removeProperty('background-color');
            } else {
              // Add highlight to this row
              targetRow.classList.add('row-persistent-highlight');
              targetRow.style.backgroundColor = '#334155';
            }
          }
        }
      });
    }

    /**
     * Adds a temporary flash effect to a button.
     */
    function flashButton(event) {
      if (!event || !event.target) return;
      
      const button = event.target;
      const originalBgColor = button.style.backgroundColor;
      const originalColor = button.style.color;
      
      // Get button color from button definition
      let flashColor = '#8b5cf6'; // default
      if (button.classList.contains('btn-ready')) flashColor = '#34d399';
      else if (button.classList.contains('btn-ask')) flashColor = '#60a5fa';
      else if (button.classList.contains('btn-arrive')) flashColor = '#8b5cf6';
      else if (button.classList.contains('btn-cancel')) flashColor = '#f87171';
      else if (button.classList.contains('btn-undo')) flashColor = '#fbbf24';
      
      // Apply flash
      button.style.backgroundColor = flashColor;
      button.style.color = '#ffffff';
      
      // Remove flash after brief moment
      setTimeout(() => {
        button.style.backgroundColor = originalBgColor;
        button.style.color = originalColor;
      }, 200);
    }

    /**
     * Handles customer actions. Updates status without changing buttons.
     */
    function handleReady(booking_number, customer_name, event) {
      console.log(`ACTION: Marking customer ${customer_name} (#${booking_number}) as ready.`);
      console.log(`INFO: [${customer_name}, #${booking_number}] 고객님께 테이블이 준비되었음을 알립니다.`);
      
      // Check if mobile - on desktop, highlight the row and flash button
      const isMobile = window.innerWidth <= 768;
      
      if (!isMobile) {
        // Desktop: Flash row (temporary) and flash button
        highlightRow(booking_number, true);
        flashButton(event);
      }
      
      // Just update the status, don't change UI
      const item = mockWaitlist.find(item => item.booking_number === booking_number);
      if (item) {
        item.status = 'Ready';
      }
    }

    function handleAsk(booking_number, customer_name, event) {
      console.log(`ACTION: Asking customer ${customer_name} (#${booking_number}).`);
      console.log(`INFO: [${customer_name}, #${booking_number}]에게 메시지/문의 창을 엽니다.`);
      
      // Check if mobile - on desktop, highlight the row and flash button
      const isMobile = window.innerWidth <= 768;
      
      if (!isMobile) {
        // Desktop: Flash row (temporary) and flash button
        highlightRow(booking_number, true);
        flashButton(event);
      }
    }

    /**
     * Handles customer actions (Arrive). Updates initialScrollTop and performs scroll.
     */
    function handleArrive(booking_number, customer_name) {
      console.log(`ACTION: Customer ${customer_name} (#${booking_number}) has arrived.`);
      const item = mockWaitlist.find(item => item.booking_number === booking_number);
      let shouldScroll = false;

      if (item) {
        // Check if item was active before status change (Waiting or Ready)
        const wasActive = item.status === 'Waiting' || item.status === 'Ready';
        item.status = 'Arrived';
        item.time_cleared = Date.now(); // Set time_cleared when arrived

        if (wasActive && rowHeight > 0) {
          // 1. Update initialScrollTop by moving up one row's height to show the cleared item
          initialScrollTop -= rowHeight;
          console.log(`SCROLL_UPDATE: Arrive. Subtracting rowHeight (${rowHeight.toFixed(2)}px) from initialScrollTop.`);
          console.log(`SCROLL_UPDATE: New initialScrollTop: ${initialScrollTop.toFixed(2)}px`);
          shouldScroll = true;
        }
      }
      // Rerender after action to update the table structure and sort order
      renderWaitlist();

      // IMPORTANT FIX: Scroll must happen AFTER the DOM is updated by renderWaitlist.
      if (shouldScroll) {
        requestAnimationFrame(() => {
          // Find the position of the just completed item in the DOM
          const rows = waitlistBody.getElementsByTagName('tr');
          let targetScrollTop = 0;
          let itemFound = false;

          // Look for the row that contains the just completed item
          for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            const idCell = row.querySelector('td:first-child');
            if (idCell && idCell.textContent.trim() === booking_number.toString()) {
              // Found the just completed item - scroll to show it at the top
              itemFound = true;
              break;
            }
            targetScrollTop += row.offsetHeight;
          }

          if (itemFound) {
            waitlistContainer.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
            console.log(`SCROLL_ACTION_RAF: Arrive scroll to show item #${booking_number} at ${targetScrollTop.toFixed(2)}px`);
            initialScrollTop = targetScrollTop;

            // Add highlight effect to the completed item
            setTimeout(() => {
              const targetRow = Array.from(rows).find(row => {
                const idCell = row.querySelector('td:first-child');
                return idCell && idCell.textContent.trim() === booking_number.toString();
              });

              if (targetRow) {
                targetRow.classList.add('arrive-highlight');
                console.log(`HIGHLIGHT: Added purple highlight to Arrive item #${booking_number}`);

                // Remove highlight after 1 second
                setTimeout(() => {
                  targetRow.classList.remove('arrive-highlight');
                  targetRow.classList.add('fade-out-highlight');

                  // Clean up fade-out class
                  setTimeout(() => {
                    targetRow.classList.remove('fade-out-highlight');
                  }, 700);
                }, 1000);
              }
            }, 300); // Small delay to ensure smooth scroll is started
          } else {
            console.log(`SCROLL_ACTION_RAF: Could not find item #${booking_number} in DOM`);
          }
        });
      }
    }

    /**
     * Handles customer actions (Cancel). Updates initialScrollTop and performs scroll.
     */
    function handleCancel(booking_number, customer_name) {
      console.log(`ACTION: Cancelling customer ${customer_name} (#${booking_number}).`);
      const item = mockWaitlist.find(item => item.booking_number === booking_number);
      let shouldScroll = false;

      if (item) {
        // Check if item was active before status change (Waiting or Ready)
        const wasActive = item.status === 'Waiting' || item.status === 'Ready';
        item.status = 'Cancelled';
        item.time_cleared = Date.now(); // Set time_cleared when cancelling

        if (wasActive && rowHeight > 0) {
          // 1. Update initialScrollTop by moving up one row's height to show the cleared item
          initialScrollTop -= rowHeight;
          console.log(`SCROLL_UPDATE: Cancel. Subtracting rowHeight (${rowHeight.toFixed(2)}px) from initialScrollTop.`);
          console.log(`SCROLL_UPDATE: New initialScrollTop: ${initialScrollTop.toFixed(2)}px`);
          shouldScroll = true;
        }
      }
      // Rerender after action to update the table structure and sort order
      renderWaitlist();

      // IMPORTANT FIX: Scroll must happen AFTER the DOM is updated by renderWaitlist.
      if (shouldScroll) {
        requestAnimationFrame(() => {
          // Find the position of the just completed item in the DOM
          const rows = waitlistBody.getElementsByTagName('tr');
          let targetScrollTop = 0;
          let itemFound = false;

          // Look for the row that contains the just completed item
          for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            const idCell = row.querySelector('td:first-child');
            if (idCell && idCell.textContent.trim() === booking_number.toString()) {
              // Found the just completed item - scroll to show it at the top
              itemFound = true;
              break;
            }
            targetScrollTop += row.offsetHeight;
          }

          if (itemFound) {
            waitlistContainer.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
            console.log(`SCROLL_ACTION_RAF: Cancel scroll to show item #${booking_number} at ${targetScrollTop.toFixed(2)}px`);
            initialScrollTop = targetScrollTop;

            // Add highlight effect to the completed item
            setTimeout(() => {
              const targetRow = Array.from(rows).find(row => {
                const idCell = row.querySelector('td:first-child');
                return idCell && idCell.textContent.trim() === booking_number.toString();
              });

              if (targetRow) {
                targetRow.classList.add('cancel-highlight');
                console.log(`HIGHLIGHT: Added red highlight to Cancel item #${booking_number}`);

                // Remove highlight after 1 second
                setTimeout(() => {
                  targetRow.classList.remove('cancel-highlight');
                  targetRow.classList.add('fade-out-highlight');

                  // Clean up fade-out class
                  setTimeout(() => {
                    targetRow.classList.remove('fade-out-highlight');
                  }, 700);
                }, 1000);
              }
            }, 300); // Small delay to ensure smooth scroll is started
          } else {
            console.log(`SCROLL_ACTION_RAF: Could not find item #${booking_number} in DOM`);
          }
        });
      }
    }

    /**
     * Handles Undo action for completed items (Arrived/Cancelled).
     * Restores the item to "Waiting" status with highlight effect.
     */
    function handleUndo(booking_number, customer_name) {
      console.log(`ACTION: Undo for customer ${customer_name} (#${booking_number}).`);
      const item = mockWaitlist.find(item => item.booking_number === booking_number);
      
      if (item && (item.status === 'Arrived' || item.status === 'Cancelled')) {
        const wasCompleted = true;
        item.status = 'Waiting';
        item.time_cleared = null; // Clear the completion time
        
        if (wasCompleted && rowHeight > 0) {
          // Adjust initialScrollTop when moving item from completed to active
          initialScrollTop += rowHeight;
          console.log(`SCROLL_UPDATE: Undo. Adding rowHeight (${rowHeight.toFixed(2)}px) to initialScrollTop.`);
          console.log(`SCROLL_UPDATE: New initialScrollTop: ${initialScrollTop.toFixed(2)}px`);
        }
      }
      
      renderWaitlist();
      
      // Add highlight effect to the restored item
      requestAnimationFrame(() => {
        const rows = waitlistBody.getElementsByTagName('tr');
        const targetRow = Array.from(rows).find(row => {
          const idCell = row.querySelector('td:first-child');
          return idCell && idCell.textContent.trim() === booking_number.toString();
        });

        if (targetRow) {
          targetRow.classList.add('arrive-highlight'); // Reuse purple highlight for Undo
          console.log(`HIGHLIGHT: Added purple highlight to Undo item #${booking_number}`);

          // Remove highlight after 1 second
          setTimeout(() => {
            targetRow.classList.remove('arrive-highlight');
            targetRow.classList.add('fade-out-highlight');

            // Clean up fade-out class
            setTimeout(() => {
              targetRow.classList.remove('fade-out-highlight');
            }, 700);
          }, 1000);
        }
      });
    }

    /**
     * Helper function to determine sorting priority.
     * Arrived and Cancelled should come first (lower number = higher priority).
     * @returns {number} The sort priority (0 for completed/cancelled, 1 for active).
     */
    function getSortPriority(status) {
      if (status === 'Arrived' || status === 'Cancelled') {
        return 0; // Highest priority (comes first)
      }
      return 1; // Lower priority (comes after 0)
    }

    /**
     * The core logic for determining scroll target, dynamic height, and button state.
     * 이 함수는 Active Queue 위치를 계산하고, 동적 높이 조절을 수행하며,
     * 스크롤 위치에 따라 버튼의 활성화/비활성화 상태를 결정합니다.
     * @returns {number} The scroll target position (total height of completed items).
     */
    function updateScrollAndButtonState() {
      //console.groupCollapsed("STATE_CHECK: Running updateScrollAndButtonState...");
      const rows = waitlistBody.getElementsByTagName('tr');
      if (!waitlistContainer || rows.length === 0 || !scrollButton) {
        console.log("STATE_CHECK: Pre-requisites missing. Exiting.");
        console.groupEnd();
        return 0;
      }

      // 1. Determine the height to scroll past (completed items)
      let totalHeightToScroll = 0;
      const completedItemsCount = mockWaitlist.filter(item => getSortPriority(item.status) === 0).length;
      const hasCompletedItems = completedItemsCount > 0;
      const totalRows = mockWaitlist.length;
      const shouldEnableScrolling = totalRows > displayedRows && hasCompletedItems;

      if (shouldEnableScrolling) {
        // Calculate height of completed rows (only if we should scroll)
        for (let i = 0; i < completedItemsCount && i < rows.length; i++) {
          totalHeightToScroll += rows[i].offsetHeight;
        }
      }

      /*
      console.log(`--- Scroll/Height Calculation ---`);
      console.log(`Total rows: ${totalRows}, displayedRows: ${displayedRows}, Completed items: ${completedItemsCount}`);
      console.log(`shouldEnableScrolling: ${shouldEnableScrolling}`);
      console.log(`Calculated scroll target (total height of completed items): ${totalHeightToScroll.toFixed(2)}px`);
      */

      // --- Dynamic Height/Scroll Activation ---
      if (shouldEnableScrolling) {
        // Force height to show exactly displayedRows number of rows
        //console.log(`HEIGHT: Forcing container height to show exactly ${displayedRows} rows.`);
        let displayedRowsHeight = 0;
        // Calculate height of exactly displayedRows number of rows
        for (let i = 0; i < Math.min(displayedRows, rows.length); i++) {
          displayedRowsHeight += rows[i].offsetHeight;
        }
        const headerHeight = waitlistContainer.querySelector('thead').offsetHeight;
        const forcedHeight = displayedRowsHeight + headerHeight + 5;

        //console.log(`HEIGHT: Setting forced height to ${forcedHeight.toFixed(2)}px (${displayedRows} rows + header)`);
        waitlistContainer.classList.remove(MAX_HEIGHT_CLASS);
        waitlistContainer.style.height = `${forcedHeight}px`;
      } else {
        // Revert to max-height setup when scrolling is not needed
        //console.log("HEIGHT: Reverting to max-height (no scrolling needed).");

        // DEBUG: Check if we should calculate exact height even when no scrolling needed
        if (totalRows === displayedRows) {
          let allRowsHeight = 0;
          for (let i = 0; i < rows.length; i++) {
            allRowsHeight += rows[i].offsetHeight;
          }
          const headerHeight = waitlistContainer.querySelector('thead').offsetHeight;
          const exactHeight = allRowsHeight + headerHeight + 10; // Extra padding for safety

          //console.log(`HEIGHT: Total rows equals displayedRows (${displayedRows}). Setting exact height to ${exactHeight.toFixed(2)}px`);
          waitlistContainer.classList.remove(MAX_HEIGHT_CLASS);
          waitlistContainer.style.height = `${exactHeight}px`;
        } else {
          waitlistContainer.classList.add(MAX_HEIGHT_CLASS);
          waitlistContainer.style.height = '';
        }
      }

      // Recalculate scroll state after potential height adjustments
      const isNowScrollable = waitlistContainer.scrollHeight > waitlistContainer.clientHeight;

      // Check if the current position is the Active Queue position (tolerance of 10px for browser precision)
      const isScrolledToActive = shouldEnableScrolling && totalHeightToScroll > 0 &&
        waitlistContainer.scrollTop >= (totalHeightToScroll - 10) &&
        waitlistContainer.scrollTop <= (totalHeightToScroll + 10);

      /*
      console.log(`--- Current Scroll State ---`);
      console.log(`isInitialScrollDone: ${isInitialScrollDone}`);
      console.log(`shouldEnableScrolling: ${shouldEnableScrolling}`);
      console.log(`isNowScrollable: ${isNowScrollable}`);
      console.log(`Current ScrollTop: ${waitlistContainer.scrollTop.toFixed(2)}px`);
      console.log(`initialScrollTop: ${initialScrollTop.toFixed(2)}px`);
      console.log(`isScrolledToActive: ${isScrolledToActive} (Is scroll position within +/- 10px of target)`);
      */

      // 2. Button State Update (Dynamic)

      if (!isInitialScrollDone) {
        // 초기 로드 시에는 비활성화 상태 유지
        //console.log(`--- BUTTON STATE DECISION ---`);
        //console.log("BUTTON: DISABLED. Reason: Initial setup (isInitialScrollDone=false).");
        scrollButton.disabled = true;
        scrollButton.textContent = "@ Active Queue";
        scrollButton.classList.remove('bg-yellow-600', 'text-slate-900', 'hover:bg-yellow-700', 'border-yellow-500');
        scrollButton.classList.add('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'border-slate-600');
        console.groupEnd();
        return totalHeightToScroll; // Early exit during initial setup
      }

      // isInitialScrollDone = true 일 때의 동적 로직:
      // 총 행 수가 minRowDisplay를 초과하고, Active Queue를 건너뛸 기록이 있고, 스크롤이 가능하며, 현재 Active Queue 위치에 있지 않은 경우 활성화
      const shouldEnableScrollDown = shouldEnableScrolling && isNowScrollable && !isScrolledToActive;

      //console.log(`--- BUTTON STATE DECISION (Dynamic) ---`);
      //console.log(`Should Enable? (shouldEnableScrolling && isScrollable && !isAtActive): ${shouldEnableScrollDown}`);


      if (shouldEnableScrollDown) {
        // ENABLED: User has manually scrolled away.
        //console.log(`BUTTON: ENABLED. Reason: Active history exists, scrollable, and user is not at the Active Queue.`);

        scrollButton.disabled = false;
        scrollButton.textContent = "Scroll to Active";
        scrollButton.classList.remove('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'border-slate-600');
        scrollButton.classList.add('bg-yellow-600', 'text-slate-900', 'hover:bg-yellow-700', 'border-yellow-500');
      } else {
        // DISABLED: At the active queue, no history, or not scrollable.

        scrollButton.disabled = true;

        // Display appropriate text for the disabled state
        if (isScrolledToActive) {
          //console.log(`BUTTON: DISABLED. Reason: Already at the Active Queue position.`);
          scrollButton.textContent = "@ Active Queue";
        } else if (!shouldEnableScrolling) {
          if (totalRows <= displayedRows) {
            //console.log(`BUTTON: DISABLED. Reason: Total rows (${totalRows}) <= displayedRows (${displayedRows}). All items visible.`);
            scrollButton.textContent = "Showing All";
          } else {
            //console.log(`BUTTON: DISABLED. Reason: No completed history to scroll past.`);
            scrollButton.textContent = "Scroll to Active";
          }
        } else if (!isNowScrollable) {
          //console.log(`BUTTON: DISABLED. Reason: Container is not scrollable (list is short).`);
          scrollButton.textContent = "Scroll to Active";
        } else {
          //console.log(`BUTTON: DISABLED. Reason: Default disabled state.`);
          scrollButton.textContent = "Scroll to Active";
        }

        scrollButton.classList.remove('bg-yellow-600', 'text-slate-900', 'hover:bg-yellow-700', 'border-yellow-500');
        scrollButton.classList.add('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'border-slate-600');
      }

      console.groupEnd(); // End STATE_CHECK group
      return totalHeightToScroll;
    }

    /**
     * Button click handler: Scrolls DOWN to the Active Queue instantly.
     */
    function handleScrollToActive() {
      console.log("ACTION: Scroll button clicked.");
      // 이제 scrollTarget은 initialScrollTop이 아니라, DOM을 기준으로 재계산된 정확한 값입니다.
      const totalHeightToScroll = updateScrollAndButtonState();

      // 버튼이 활성화된 상태일 때만 스크롤을 수행합니다.
      if (!scrollButton.disabled) {
        console.log(`SCROLL_ACTION: Performing scroll to ${totalHeightToScroll.toFixed(2)}px.`);
        // 'auto'를 사용하여 즉시 이동하고, 스크롤 이벤트 발생을 최소화합니다.
        waitlistContainer.scrollTo({ top: totalHeightToScroll, behavior: 'smooth' });

        // 스크롤 완료 후 버튼 상태를 즉시 업데이트하여 비활성화합니다.
        requestAnimationFrame(updateScrollAndButtonState);
      } else {
        console.log("SCROLL_ACTION: Scroll prevented, button is disabled.");
      }
    }


    /**
     * Renders the table based on the waitlist data. Called on initial load and on status change.
     */
    function renderWaitlist() {
      console.log("RENDER: Starting table render.");

      // Clean up mobile state on desktop
      if (window.innerWidth > 768) {
        document.querySelectorAll('.row-selected').forEach(row => {
          row.classList.remove('row-selected');
        });
        document.querySelectorAll('.mobile-action-row').forEach(row => {
          row.remove();
        });
        expandedRowId = null;
      }

      // 1. Sort the entire list: Completed items first (by time_cleared), then Active items by time_created (oldest first).
      mockWaitlist.sort((a, b) => {
        const priorityA = getSortPriority(a.status);
        const priorityB = getSortPriority(b.status);

        if (priorityA !== priorityB) {
          return priorityA - priorityB;
        }

        // Both items have the same priority level
        if (priorityA === 0) {
          // Both are completed items - sort by time_cleared (oldest first, recent last)
          return (a.time_cleared || 0) - (b.time_cleared || 0);
        } else {
          // Both are active items - sort by time_created (oldest first)
          return a.time_created - b.time_created;
        }
      });

      const completedItemsCount = mockWaitlist.filter(item => getSortPriority(item.status) === 0).length;
      console.log(`RENDER: Sorted list. Total items: ${mockWaitlist.length}, Completed items count: ${completedItemsCount}`);

      waitlistBody.innerHTML = ''; // Clear table content

      let tableHTML = '';
      mockWaitlist.forEach((item) => {
        const statusPriority = getSortPriority(item.status);
        const rowClass = statusPriority === 0 ? 'row-completed' : 'row-hover bg-slate-900';
        const statusData = getStatusIconAndClass(item.status);
        const timeData = formatElapsedTime(item);
        
        // Dynamic color classes based on item status
        const idClass = statusPriority === 0 ? 'text-slate-200' : 'text-amber-400';
        const nameClass = statusPriority === 0 ? 'text-slate-100' : 'text-amber-400';
        const paxClass = statusPriority === 0 ? 'text-slate-300' : 'text-amber-400';
        const timeClass = statusPriority === 0 ? 'text-slate-200' : 'text-amber-400';

        // Get chat history for this booking_list_id
        const chatHistory = mockChatList
          .filter(chat => chat.booking_list_id === item.booking_list_id)
          .sort((a, b) => a.dateTime - b.dateTime); // Sort by dateTime ascending

        // Build chat history HTML with elapsed time
        let chatHistoryHTML = '';
        if (chatHistory.length > 0) {
          const chatClass = statusPriority === 0 ? 'text-slate-400' : 'text-slate-400';
          const hasStatusMessage = item.status === 'Arrived' || item.status === 'Cancelled';
          
          chatHistoryHTML = chatHistory.map((chat, index) => {
            let elapsedTime;
            const isLastMessage = index === chatHistory.length - 1;
            
            if (isLastMessage && !hasStatusMessage) {
              // Last message and no status message to follow: calculate ongoing elapsed time from message dateTime to now
              const elapsedMs = Date.now() - chat.dateTime;
              const totalSeconds = Math.floor(elapsedMs / 1000);
              const minutes = Math.floor(totalSeconds / 60);
              const seconds = String(totalSeconds % 60).padStart(2, '0');
              
              if (minutes >= 60) {
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = String(minutes % 60).padStart(2, '0');
                elapsedTime = `${hours}:${remainingMinutes}:${seconds}`;
              } else {
                elapsedTime = `${minutes}:${seconds}`;
              }
            } else {
              // Not last message OR last message with status to follow: calculate fixed elapsed time to next event
              let nextEventTime;
              if (isLastMessage && hasStatusMessage) {
                // Calculate time to status event (time_cleared)
                nextEventTime = item.time_cleared;
              } else {
                // Calculate time to next chat message
                const nextChat = chatHistory[index + 1];
                nextEventTime = nextChat.dateTime;
              }
              
              const elapsedMs = nextEventTime - chat.dateTime;
              const totalSeconds = Math.floor(elapsedMs / 1000);
              const minutes = Math.floor(totalSeconds / 60);
              const seconds = String(totalSeconds % 60).padStart(2, '0');
              
              if (minutes >= 60) {
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = String(minutes % 60).padStart(2, '0');
                elapsedTime = `${hours}:${remainingMinutes}:${seconds}`;
              } else {
                elapsedTime = `${minutes}:${seconds}`;
              }
            }
            
            // Add a data attribute to identify ongoing messages for live updates (only if truly last and no status)
            const dataAttr = (isLastMessage && !hasStatusMessage) ? `data-chat-id="${chat.Id}" data-chat-time="${chat.dateTime}"` : '';
            
            // Apply green color (#34d399) for "Q: Table is Ready. Coming?" message (same as Ready button)
            const messageChatClass = chat.qna.includes('Table is Ready') ? 'text-emerald-400' : chatClass;
            
            return `<div class="text-xs ${messageChatClass} leading-relaxed" ${dataAttr}>↳ [${elapsedTime}] ${chat.qna}</div>`; //arrow
          }).join('');

          // Add status message if item is Arrived or Cancelled (without elapsed time)
          if (hasStatusMessage) {
            // Apply color based on status: purple for Arrived (#8b5cf6), red for Cancelled (#f87171)
            const statusColor = item.status === 'Arrived' ? 'text-purple-500' : 'text-red-400';
            chatHistoryHTML += `<div class="text-xs ${statusColor} leading-relaxed">↳ ${item.status}</div>`;
          }
        }

        // Action Buttons - Generate using button definitions
        const buttons = getButtonsForStatus(item.status);
        const buttonHTMLs = buttons.map(btnDef => generateButtonHTML(btnDef, item.booking_number, item.customer_name, false));
        const actionButtons = buttonHTMLs.join('\n');
        const actionContainerClass = 'flex gap-1.5';

        // Build time cell HTML - two lines for completed items, one line for active items
        let timeHTML;
        if (timeData.isTwoLine) {
          timeHTML = `
            <div class="font-mono tracking-wider">${timeData.time}</div>
            <div class="text-xs font-mono">(${timeData.duration})</div>
          `;
        } else {
          timeHTML = `<div class="font-mono tracking-wider">${timeData.time}</div>`;
        }

        // Mobile: Add onclick handler, Desktop: no onclick
        // Always add onclick - the function itself checks if mobile
        const onclickAttr = `onclick="toggleMobileActions(${item.booking_number}, event)"`;
        const rowClickableClass = 'row-clickable';

        tableHTML += `
                    <tr class="${rowClass} ${rowClickableClass}" data-item-id="${item.booking_number}" ${onclickAttr}>
                        <td class="px-2 py-2 whitespace-nowrap text-sm font-medium ${idClass} text-center">${item.booking_number}</td>
                        <td class="px-2 py-2 text-sm">
                            <div class="font-semibold ${nameClass}">${item.customer_name}</div>
                            ${chatHistoryHTML}
                        </td>
                        <td class="px-2 py-2 whitespace-nowrap text-sm ${paxClass} font-bold text-center">${item.pax}</td>
                        <td id="time-${item.booking_number}" class="px-2 py-2 whitespace-nowrap text-sm text-center ${timeClass}">
                            ${timeHTML}
                        </td>
                        <td class="action-column-cell px-2 py-2 whitespace-nowrap text-center text-sm font-medium">
                            <div class="${actionContainerClass}">
                                ${actionButtons}
                            </div>
                        </td>
                    </tr>
                 `;
      });

      waitlistBody.innerHTML = tableHTML;
      console.log("RENDER: Table HTML injected into DOM.");

      // Debug: Check for any row-selected classes on desktop
      if (window.innerWidth > 768) {
        // Force remove any inline styles or problematic classes
        const allRows = waitlistBody.querySelectorAll('tr');
        
        // Clean up mobile-related classes
        allRows.forEach((row) => {
          row.removeAttribute('style'); // Remove any inline styles
          row.classList.remove('row-selected'); // Remove row-selected if exists
        });
      }

      // Close any expanded mobile row when re-rendering
      expandedRowId = null;

      // NOTE: 데이터가 변경되어 렌더링이 발생하면, 버튼 상태와 스크롤 타겟을 즉시 업데이트합니다.
      updateScrollAndButtonState();
    }

    /**
     * Updates the elapsed time for all items every second.
     * Updates the HTML content of the time cell to support two-line display.
     * Also updates ongoing chat message elapsed times.
     */
    function updateElapsedTimes() {
      mockWaitlist.forEach(item => {
        const timeElement = document.getElementById(`time-${item.booking_number}`);
        if (timeElement) {
          const timeData = formatElapsedTime(item);
          
          // Build time cell HTML - two lines for completed items, one line for active items
          let timeHTML;
          if (timeData.isTwoLine) {
            timeHTML = `
              <div class="font-mono tracking-wider">${timeData.time}</div>
              <div class="text-xs font-mono">(${timeData.duration})</div>
            `;
          } else {
            timeHTML = `<div class="font-mono tracking-wider">${timeData.time}</div>`;
          }
          
          timeElement.innerHTML = timeHTML;
        }
      });

      // Update ongoing chat message elapsed times (messages with data-chat-id attribute)
      document.querySelectorAll('[data-chat-id]').forEach(chatElement => {
        const chatTime = parseInt(chatElement.getAttribute('data-chat-time'));
        if (chatTime) {
          const elapsedMs = Date.now() - chatTime;
          const totalSeconds = Math.floor(elapsedMs / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = String(totalSeconds % 60).padStart(2, '0');
          
          let elapsedTime;
          if (minutes >= 60) {
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = String(minutes % 60).padStart(2, '0');
            elapsedTime = `${hours}:${remainingMinutes}:${seconds}`;
          } else {
            elapsedTime = `${minutes}:${seconds}`;
          }
          
          // Extract the message text (everything after the closing bracket ']')
          const currentText = chatElement.textContent;
          const messageStart = currentText.indexOf(']') + 1;
          const messageText = currentText.substring(messageStart);
          
          // Update the entire text with new elapsed time
          chatElement.textContent = `↳ [${elapsedTime}]${messageText}`; //arrow
        }
      });
    }

    // --- Initial Setup ---

    // 0. Clean up any stray mobile state classes on load
    document.querySelectorAll('.row-selected').forEach(row => {
      row.classList.remove('row-selected');
    });
    document.querySelectorAll('.mobile-action-row').forEach(row => {
      row.remove();
    });

    // 1. Initial rendering of the table content
    renderWaitlist(); // This now calls updateScrollAndButtonState() once

    // 2. Add scroll event listener. 
    // 사용자가 스크롤을 시작하면 버튼 상태가 동적으로 업데이트됩니다.
    waitlistContainer.addEventListener('scroll', updateScrollAndButtonState);

    // 3. Initial scroll setup: Set position and initial button state immediately after render.
    // requestAnimationFrame을 사용하여 DOM이 렌더링된 후 정확한 위치로 이동합니다.
    requestAnimationFrame(() => {
      console.log("INIT: DOM rendered. Starting initial scroll/state calculation.");

      // 1. 초기 스크롤 목표 위치를 계산하고 동적 높이 설정을 업데이트합니다.
      const scrollTarget = updateScrollAndButtonState();
      const completedItemsCount = mockWaitlist.filter(item => getSortPriority(item.status) === 0).length;

      const rows = waitlistBody.getElementsByTagName('tr');
      // NEW: Calculate row height based on a rendered row (must be done after render)
      if (rows.length > 0) {
        rowHeight = rows[0].offsetHeight;
        console.log(`INIT: Measured single rowHeight for update: ${rowHeight.toFixed(2)}px`);
      }

      console.log(`INIT: Calculated scrollTarget = ${scrollTarget.toFixed(2)}px. Completed items = ${completedItemsCount}`);

      // 2. 총 행 수가 displayedRows를 초과하고, Active Queue를 건너뛸 기록이 있고, 스크롤이 가능하며, 현재 Active Queue 위치에 있지 않은 경우 활성화
      const totalRows = mockWaitlist.length;
      const shouldScrollToActive = totalRows > displayedRows && completedItemsCount > 0;
      console.log(`INIT: Total rows: ${totalRows}, displayedRows: ${displayedRows}, shouldScrollToActive: ${shouldScrollToActive}`);

      if (shouldScrollToActive) {
        // Disable hover temporarily during scroll
        waitlistContainer.classList.add('disable-hover');
        
        // 스크롤 위치를 즉시 설정합니다. (비헤이비어 'auto')
        waitlistContainer.scrollTop = scrollTarget;
        console.log(`INIT: Forced scroll to position: ${scrollTarget.toFixed(2)}px`);

        // Re-enable hover only when the user actually interacts (mousemove or window focus)
        const reenableHover = () => {
          waitlistContainer.classList.remove('disable-hover');
          console.log('INIT: Hover re-enabled after user interaction');
          document.removeEventListener('mousemove', reenableHover);
          window.removeEventListener('focus', reenableHover);
          clearTimeout(reenableFallback);
        };

        // If the user moves the mouse (or window gains focus), re-enable hover immediately
        document.addEventListener('mousemove', reenableHover, { once: true });
        window.addEventListener('focus', reenableHover, { once: true });

        // Fallback: if no interaction occurs within 8s, re-enable to avoid permanently disabling hover
        const reenableFallback = setTimeout(() => {
          waitlistContainer.classList.remove('disable-hover');
          console.log('INIT: Hover re-enabled by fallback after 8s');
          document.removeEventListener('mousemove', reenableHover);
          window.removeEventListener('focus', reenableHover);
        }, 8000);

        // 실제 스크롤된 위치를 다음 프레임에서 읽어서 정확한 값을 저장
        requestAnimationFrame(() => {
          // 더 정확한 스크롤을 위해 한 번 더 시도
          const actualScrollTop = waitlistContainer.scrollTop;
          if (Math.abs(actualScrollTop - scrollTarget) > 2) {
            console.log(`INIT: Adjusting scroll position. First attempt: ${actualScrollTop.toFixed(2)}px`);
            waitlistContainer.scrollTop = scrollTarget;

            // 조정 후 다시 한번 확인
            requestAnimationFrame(() => {
              initialScrollTop = waitlistContainer.scrollTop;
              console.log(`INIT: InitialScrollTop value recorded (final): ${initialScrollTop.toFixed(2)}px`);
              console.log(`INIT: Final difference: ${(scrollTarget - initialScrollTop).toFixed(2)}px`);
            });
          } else {
            initialScrollTop = actualScrollTop;
            console.log(`INIT: InitialScrollTop value recorded (actual): ${initialScrollTop.toFixed(2)}px`);
            console.log(`INIT: Difference between target and actual: ${(scrollTarget - initialScrollTop).toFixed(2)}px`);
          }
        });
      } else {
        initialScrollTop = 0; // Ensure it's 0 if no initial scroll occurred
        console.log("INIT: No completed items, skipping initial forced scroll.");
      }

      // 3. 스크롤 위치 설정 직후 버튼 상태를 업데이트하여 즉시 비활성화하고 텍스트를 변경합니다.
      updateScrollAndButtonState();
      console.log("INIT: Final button state check completed.");

      // 4. 초기 설정이 완료되었음을 플래그로 표시합니다. 
      isInitialScrollDone = true;
      console.log("INIT: isInitialScrollDone set to TRUE. Enabling dynamic button logic.");
    });

    // 4. Set up the non-rendering interval:
    // Updates elapsed times every second.
    setInterval(updateElapsedTimes, 1000);

    // 5. Add window resize listener: Scrollability and height calculations change on resize.
    // 창 크기가 변경될 때 버튼 상태를 업데이트합니다.
    window.addEventListener('resize', () => {
      updateScrollAndButtonState();
      
      // Clean up mobile state when switching to desktop
      if (window.innerWidth > 768) {
        // Remove all mobile action rows
        document.querySelectorAll('.mobile-action-row').forEach(row => row.remove());
        // Remove all row-selected classes
        document.querySelectorAll('.row-selected').forEach(row => {
          row.classList.remove('row-selected');
        });
        // Reset expanded row tracking
        expandedRowId = null;
        console.log('RESIZE: Switched to desktop, cleaned up mobile state');
      }
    });
  </script>
</body>

</html>