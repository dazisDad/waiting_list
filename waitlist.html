<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Waitlist Manager</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght400;600;700&display=swap" rel="stylesheet">
  <style>
    /* Inter font application and base style - Dark Modern Theme */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #0f172a;
      color: #e2e8f0;
    }

    /* Status Colors for Icon - Neon effect for dark theme */
    .status-waiting {
      color: #fbbf24;
      text-shadow: 0 0 8px rgba(251, 191, 36, 0.5);
    }

    .status-called {
      color: #fb923c;
      text-shadow: 0 0 8px rgba(251, 146, 60, 0.5);
    }

    .status-checkedin {
      color: #8b5cf6;
      text-shadow: 0 0 8px rgba(139, 92, 246, 0.5);
    }

    .status-cancelled {
      color: #f87171;
      text-shadow: 0 0 8px rgba(248, 113, 113, 0.5);
    }

    /* Dark Modern Button Styles */
    .action-button {
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }

    .action-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px -4px rgba(0, 0, 0, 0.4);
    }

    /* Outline button styles - Call */
    .btn-call {
      background-color: transparent;
      border-color: #34d399;
      color: #34d399;
    }
    .btn-call:hover:not(:disabled) {
      background-color: #34d399;
      color: #ffffff;
    }

    /* Outline button styles - Ask */
    .btn-ask {
      background-color: transparent;
      border-color: #60a5fa;
      color: #60a5fa;
    }
    .btn-ask:hover:not(:disabled) {
      background-color: #60a5fa;
      color: #ffffff;
    }

    /* Outline button styles - Check-In */
    .btn-checkin {
      background-color: transparent;
      border-color: #8b5cf6;
      color: #8b5cf6;
    }
    .btn-checkin:hover:not(:disabled) {
      background-color: #8b5cf6;
      color: #ffffff;
    }

    /* Outline button styles - Cancel (Danger) */
    .btn-cancel {
      background-color: transparent;
      border-color: #f87171;
      color: #f87171;
    }
    .btn-cancel:hover:not(:disabled) {
      background-color: #f87171;
      color: #ffffff;
    }

    /* Outline button styles - Undo */
    .btn-undo {
      background-color: transparent;
      border-color: #fbbf24;
      color: #fbbf24;
    }
    .btn-undo:hover:not(:disabled) {
      background-color: #fbbf24;
      color: #ffffff;
    }

    /* Disabled button state */
    .action-button:disabled {
      background-color: #475569;
      border-color: #475569;
      color: #94a3b8;
      cursor: not-allowed;
      opacity: 0.6;
    }

    /* Highlight animation for completed items - Dark theme */
    .checkin-highlight {
      background-color: rgba(139, 92, 246, 0.15) !important;
      box-shadow: none !important;
      border: none !important;
      transition: all 0.3s ease-in-out;
    }

    .cancel-highlight {
      background-color: rgba(248, 113, 113, 0.15) !important;
      box-shadow: none !important;
      border: none !important;
      transition: all 0.3s ease-in-out;
    }

    .fade-out-highlight {
      background-color: transparent !important;
      box-shadow: none;
      transition: all 0.7s ease-out;
    }

    /* Button click highlight - brief flash effect */
    tbody tr.button-click-highlight,
    tbody tr.button-click-highlight:hover,
    tbody tr.row-hover.button-click-highlight,
    tbody tr.row-hover.button-click-highlight:hover,
    tbody tr.bg-slate-900.button-click-highlight,
    tbody tr.bg-slate-900.button-click-highlight:hover {
      background-color: #334155 !important;
      transition: none !important;
    }
    
    /* Override any conflicting background colors */
    .button-click-highlight.bg-slate-900 {
      background-color: #334155 !important;
    }

    /* Row hover effect */
    .row-hover:hover {
      background-color: #334155 !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    /* Completed row style */
    .row-completed {
      background-color: #1e293b;
    }
    .row-completed:hover {
      background-color: #334155 !important;
    }

    /* Disable hover during scroll to prevent unwanted highlights */
    .disable-hover .row-hover:hover,
    .disable-hover .row-completed:hover {
      background-color: inherit !important;
      box-shadow: none !important;
    }

    /* Desktop: Ensure row-selected has no effect */
    @media (min-width: 769px) {
      .row-selected {
        background-color: inherit !important;
        border-left: none !important;
        box-shadow: none !important;
      }

      /* Remove focus styles from rows on desktop */
      .row-clickable,
      .row-hover,
      .row-completed,
      tr {
        outline: none !important;
      }

      .row-clickable:focus,
      .row-clickable:focus-visible,
      .row-clickable:focus-within,
      .row-hover:focus,
      .row-hover:focus-visible,
      .row-hover:focus-within,
      .row-completed:focus,
      .row-completed:focus-visible,
      .row-completed:focus-within,
      tr:focus,
      tr:focus-visible,
      tr:focus-within {
        outline: none !important;
        background-color: inherit !important;
        box-shadow: none !important;
      }

      /* Disable pointer events on row onclick for desktop */
      .row-clickable {
        pointer-events: auto;
        cursor: default !important;
      }
    }

    /* Mobile: Hide Action column header and cells */
    @media (max-width: 768px) {
      .action-column-header,
      .action-column-cell {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }

      /* Mobile row cursor */
      .row-clickable {
        cursor: pointer;
        transition: none !important;
      }

      /* Make only the row itself clickable, not its children */
      .row-clickable > td {
        pointer-events: auto;
      }

      .row-clickable > td > * {
        pointer-events: none !important;
      }

      /* Disable all button interactions on mobile (buttons are hidden anyway) */
      .action-column-cell button,
      .action-column-cell .action-button {
        pointer-events: none !important;
        transition: none !important;
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }

      /* Force disable all button states on mobile */
      .action-column-cell .btn-ask,
      .action-column-cell .btn-ask:hover,
      .action-column-cell .btn-ask:active,
      .action-column-cell .btn-ask:focus,
      .action-column-cell .btn-ask:focus-visible {
        background-color: transparent !important;
        transition: none !important;
        pointer-events: none !important;
      }

      .action-column-cell .btn-call,
      .action-column-cell .btn-call:hover,
      .action-column-cell .btn-call:active,
      .action-column-cell .btn-call:focus,
      .action-column-cell .btn-call:focus-visible {
        background-color: transparent !important;
        transition: none !important;
        pointer-events: none !important;
      }

      .action-column-cell .btn-cancel,
      .action-column-cell .btn-cancel:hover,
      .action-column-cell .btn-cancel:active,
      .action-column-cell .btn-cancel:focus,
      .action-column-cell .btn-cancel:focus-visible {
        background-color: transparent !important;
        transition: none !important;
        pointer-events: none !important;
      }

      .action-column-cell .btn-checkin,
      .action-column-cell .btn-checkin:hover,
      .action-column-cell .btn-checkin:active,
      .action-column-cell .btn-checkin:focus,
      .action-column-cell .btn-checkin:focus-visible {
        background-color: #8b5cf6 !important;
        transition: none !important;
        pointer-events: none !important;
      }

      /* Disable hover effect on mobile to avoid confusion */
      .row-hover,
      .row-completed {
        transition: none !important;
      }

      .row-hover:hover,
      .row-completed:hover {
        background-color: inherit !important;
        box-shadow: none !important;
        transition: none !important;
      }

      /* Selected row highlight on mobile - No transition for instant feedback */
      .row-selected {
        background-color: #334155 !important;
        border-left: 3px solid #8b5cf6 !important;
        transition: none !important;
      }

      .row-selected:hover {
        background-color: #334155 !important;
        box-shadow: none !important;
      }

      /* Expanded row for mobile buttons */
      .mobile-action-row {
        background-color: #1e293b;
        border-top: 1px solid #475569;
      }

      .mobile-action-row td {
        padding: 12px 8px;
      }

      /* Mobile button styles - No transition for instant feedback */
      .mobile-btn,
      .mobile-btn-call,
      .mobile-btn-ask,
      .mobile-btn-checkin,
      .mobile-btn-cancel {
        transition: none !important;
      }

      /* Mobile Call button */
      .mobile-btn-call {
        background-color: transparent;
        border: 1px solid #34d399;
        color: #34d399;
      }
      .mobile-btn-call:active {
        background-color: #34d399;
        color: #ffffff;
        transition: none !important;
      }

      /* Mobile Ask button */
      .mobile-btn-ask {
        background-color: transparent;
        border: 1px solid #60a5fa;
        color: #60a5fa;
      }
      .mobile-btn-ask:active {
        background-color: #60a5fa;
        color: #ffffff;
        transition: none !important;
      }

      /* Mobile Check-In button */
      .mobile-btn-checkin {
        background-color: transparent;
        border: 1px solid #8b5cf6;
        color: #8b5cf6;
      }
      .mobile-btn-checkin:active {
        background-color: #8b5cf6;
        color: #ffffff;
        transition: none !important;
      }

      /* Mobile Cancel button */
      .mobile-btn-cancel {
        background-color: transparent;
        border: 1px solid #f87171;
        color: #f87171;
      }
      .mobile-btn-cancel:active {
        background-color: #f87171;
        color: #ffffff;
        transition: none !important;
      }

      /* Mobile Undo button */
      .mobile-btn-undo {
        background-color: transparent;
        border: 1px solid #fbbf24;
        color: #fbbf24;
      }
      .mobile-btn-undo:active {
        background-color: #fbbf24;
        color: #ffffff;
        transition: none !important;
      }

      /* Adjust table widths for mobile */
      .mobile-adjusted-width {
        width: auto !important;
      }
    }

    /* Desktop: Hide mobile action rows */
    @media (min-width: 769px) {
      .mobile-action-row {
        display: none !important;
      }
    }
  </style>
</head>

<body class="p-4 sm:p-8">
  <!-- Dark Modern container -->
  <div class="max-w-5xl mx-auto bg-slate-800 rounded-xl shadow-2xl p-4 sm:p-6 border border-slate-700">
    <header class="mb-6 border-b border-slate-600 pb-3">
      <h1 class="text-3xl sm:text-4xl font-extrabold text-slate-100 flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
          class="w-8 h-8 text-violet-400 mr-3">
          <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
          <circle cx="12" cy="7" r="4" />
          <path d="M2 22h20" />
          <path d="M2 17h20" />
        </svg>
        Waitlist Management System
      </h1>
      <p class="text-slate-400 mt-1">Real-time queue status and customer service management</p>
    </header>

    <!-- Scroll to Active Button -->
    <div class="mb-4 flex justify-end">
      <!-- Button calls the unified scroll handler -->
      <!-- Initial state is disabled, the logic will update the text and class -->
      <button id="scroll-to-active-btn" onclick="handleScrollToActive()" disabled
        class="action-button px-4 py-2 text-sm font-semibold rounded-lg transition duration-150 bg-slate-700 text-slate-500 cursor-not-allowed border border-slate-600">
        @ Active Queue
      </button>
    </div>

    <!-- Waitlist Table -->
    <!-- Outer div maintains shadow and horizontal scroll for narrow screens -->
    <div class="shadow-2xl rounded-lg overflow-x-auto border border-slate-700">
      <!-- Inner container for vertical scrolling with fixed header -->
      <div id="waitlist-container" class="max-h-[60vh] overflow-y-auto relative bg-slate-900">
        <table class="min-w-full divide-y divide-slate-700">
          <thead class="bg-slate-800 sticky top-0 z-10 border-b border-slate-700">
            <tr>
              <!-- Reduced padding (px-2 py-2) and centered -->
              <th class="px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-1/12">No.
              </th>
              <!-- Reduced padding and width for Name column -->
              <th class="px-2 py-2 text-left text-xs font-semibold text-slate-300 uppercase tracking-wider w-2/12">Name
              </th>
              <!-- Reduced padding (px-2 py-2) and centered -->
              <th class="px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-1/12">Pax
              </th>
              <!-- Reduced padding (px-2 py-2) and centered -->
              <th class="px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-2/12">
                Elapsed Time</th>
              <!-- Reduced width for Action column - Hidden on mobile -->
              <th class="action-column-header px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-5/12">
                Action</th>
              <!-- Reduced padding (px-2 py-2) -->
              <th class="px-2 py-2 text-center text-xs font-semibold text-slate-300 uppercase tracking-wider w-1/12">
                Status</th>
            </tr>
          </thead>
          <tbody id="waitlist-body" class="bg-slate-900 divide-y divide-slate-800">
            <!-- Data will be injected here by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>

    <footer class="mt-6 text-center text-slate-500 text-sm">
      <p>Data is generated as a mockup; production environments use Firestore.</p>
    </footer>
  </div>

  <!-- Message Box for Alerts (replacing alert()) - Dark theme -->
  <div id="message-box" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4 z-50">
    <div class="bg-slate-800 p-6 rounded-lg shadow-2xl max-w-sm w-full border border-slate-700">
      <h3 class="text-lg font-bold text-slate-100 mb-4">Notification</h3>
      <p id="message-text" class="text-slate-300 mb-6"></p>
      <div class="text-right">
        <button onclick="closeMessageBox()"
          class="px-4 py-2 bg-violet-600 text-white rounded-md hover:bg-violet-700 transition duration-150 action-button border-0">
          Close
        </button>
      </div>
    </div>
  </div>

  <script>
    // Create mock waitlist data based on current time
    // Extended list for testing minRowDisplay functionality
    const mockWaitlist = [
      // Completed items (will be sorted to the top) - with time_cleared set
      { id: 1005, name: "Haneul Jung", pax: 2, time_created: Date.now() - 45 * 60 * 1000, time_cleared: Date.now() - 40 * 60 * 1000, status: "Cancelled" },
      { id: 1008, name: "Jimin Lee", pax: 3, time_created: Date.now() - 50 * 60 * 1000, time_cleared: Date.now() - 45 * 60 * 1000, status: "Check-In" },
      { id: 1010, name: "Yuna Choi", pax: 4, time_created: Date.now() - 55 * 60 * 1000, time_cleared: null, status: "Waiting" },

      // Active items (Waiting/Called) - no time_cleared
      { id: 1001, name: "Minji Kim", pax: 4, time_created: Date.now() - 35 * 60 * 1000, time_cleared: null, status: "Waiting" },
      { id: 1002, name: "Juno Lee", pax: 2, time_created: Date.now() - 30 * 60 * 1000, time_cleared: null, status: "Waiting" },
      { id: 1003, name: "Seyeon Park", pax: 3, time_created: Date.now() - 25 * 60 * 1000, time_cleared: null, status: "Called" },
      { id: 1004, name: "Eunwoo Choi", pax: 5, time_created: Date.now() - 20 * 60 * 1000, time_cleared: null, status: "Waiting" },
      { id: 1006, name: "Jihoon Kim", pax: 3, time_created: Date.now() - 15 * 60 * 1000, time_cleared: null, status: "Waiting" },
      { id: 1007, name: "Somin Park", pax: 6, time_created: Date.now() - 10 * 60 * 1000, time_cleared: null, status: "Waiting" },
      { id: 1009, name: "Taehyun Lee", pax: 2, time_created: Date.now() - 5 * 60 * 1000, time_cleared: null, status: "Waiting" },
    ];

    const waitlistBody = document.getElementById('waitlist-body');
    const messageBox = document.getElementById('message-box');
    const messageText = document.getElementById('message-text');
    const scrollButton = document.getElementById('scroll-to-active-btn');
    const waitlistContainer = document.getElementById('waitlist-container');

    // Define the Tailwind class for maximum height
    const MAX_HEIGHT_CLASS = 'max-h-[60vh]';

    // Number of rows to display on screen (including completed items)
    const displayedRows = 7;

    // --- Global State Variables ---
    let isInitialScrollDone = false;
    let initialScrollTop = 0; // 초기 스크롤 탑 값 저장 변수 (Active Queue의 시작 위치를 추적)
    let rowHeight = 0; // 단일 행의 높이 (Check-In/Cancel 시 initialScrollTop 업데이트에 사용)
    let expandedRowId = null; // 현재 확장된 행의 ID (모바일용)

    // --- Action Button Definitions ---
    const actionButtonDefinitions = [
      {
        id: 'call',
        label: 'Call',
        color: '#34d399', // green
        textColor: '#34d399',
        isBackgroundFill: false,
        functionName: 'handleCall',
        showForStatus: ['Waiting', 'Called'], // Show for these statuses
        mobileBtnClass: 'mobile-btn-call',
        desktopBtnClass: 'btn-call'
      },
      {
        id: 'ask',
        label: 'Ask',
        color: '#60a5fa', // blue
        textColor: '#60a5fa',
        isBackgroundFill: false,
        functionName: 'handleAsk',
        showForStatus: ['Waiting', 'Called'],
        mobileBtnClass: 'mobile-btn-ask',
        desktopBtnClass: 'btn-ask'
      },
      {
        id: 'checkin',
        label: 'Check-In',
        color: '#8b5cf6', // purple
        textColor: '#8b5cf6', // purple text for outline style
        isBackgroundFill: false,
        functionName: 'handleCheckIn',
        showForStatus: ['Waiting', 'Called'],
        mobileBtnClass: 'mobile-btn-checkin',
        desktopBtnClass: 'btn-checkin'
      },
      {
        id: 'cancel',
        label: 'Cancel',
        color: '#f87171', // red
        textColor: '#f87171',
        isBackgroundFill: false,
        functionName: 'handleCancel',
        showForStatus: ['Waiting', 'Called'],
        mobileBtnClass: 'mobile-btn-cancel',
        desktopBtnClass: 'btn-cancel'
      },
      {
        id: 'undo',
        label: 'Undo',
        color: '#fbbf24', // yellow/amber
        textColor: '#fbbf24',
        isBackgroundFill: false,
        functionName: 'handleUndo',
        showForStatus: ['Check-In', 'Cancelled'],
        mobileBtnClass: 'mobile-btn-undo',
        desktopBtnClass: 'btn-undo'
      }
    ];

    /**
     * Helper function to get buttons for a specific item status
     */
    function getButtonsForStatus(status) {
      return actionButtonDefinitions.filter(btn => btn.showForStatus.includes(status));
    }

    /**
     * Helper function to generate button HTML
     */
    function generateButtonHTML(buttonDef, itemId, itemName, isMobile) {
      const baseClasses = 'action-button px-3 py-1.5 rounded-md border font-medium text-sm';
      const btnClass = isMobile ? buttonDef.mobileBtnClass : buttonDef.desktopBtnClass;
      const classes = `${baseClasses} ${btnClass} flex-1`;
      
      // Determine if event parameter is needed
      const needsEvent = ['handleCall', 'handleAsk'].includes(buttonDef.functionName);
      const fnCall = needsEvent 
        ? `${buttonDef.functionName}(${itemId}, '${itemName}', event)`
        : `${buttonDef.functionName}(${itemId}, '${itemName}')`;
      
      return `<button onclick="${fnCall}" class="${classes}">${buttonDef.label}</button>`;
    }

    /**
     * Mobile: Toggle mobile action row for a specific item
     */
    function toggleMobileActions(itemId, event) {
      // Check if we're on mobile (screen width <= 768px)
      if (window.innerWidth > 768) {
        // Desktop: Remove any row-selected classes that might remain
        document.querySelectorAll('.row-selected').forEach(row => {
          row.classList.remove('row-selected');
        });
        return; // Do nothing on desktop
      }

      // Prevent event bubbling and default behavior
      if (event) {
        // If the click originated from a button, ignore it (shouldn't happen on mobile but safety check)
        if (event.target.tagName === 'BUTTON' || event.target.closest('button')) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
      }

      const mobileActionRowId = `mobile-actions-${itemId}`;
      const existingMobileRow = document.getElementById(mobileActionRowId);
      const currentRow = document.querySelector(`tr[data-item-id="${itemId}"]`);

      // If clicking the same row, close it
      if (expandedRowId === itemId) {
        if (existingMobileRow) {
          existingMobileRow.remove();
        }
        if (currentRow) {
          // Force immediate class removal
          currentRow.classList.remove('row-selected');
          // Force reflow to ensure immediate visual update
          void currentRow.offsetHeight;
        }
        expandedRowId = null;
        console.log(`MOBILE: Collapsed row for item #${itemId}`);
        return;
      }

      // If another row is expanded, close it first
      if (expandedRowId !== null) {
        const prevMobileRow = document.getElementById(`mobile-actions-${expandedRowId}`);
        if (prevMobileRow) {
          prevMobileRow.remove();
        }
        const prevRow = document.querySelector(`tr[data-item-id="${expandedRowId}"]`);
        if (prevRow) {
          prevRow.classList.remove('row-selected');
          // Force reflow
          void prevRow.offsetHeight;
        }
      }

      // Add highlight to the newly selected row immediately
      if (currentRow) {
        // Force reflow before adding class to ensure clean state
        void currentRow.offsetHeight;
        currentRow.classList.add('row-selected');
        // Force another reflow to ensure immediate application
        void currentRow.offsetHeight;
      }

      // Expand the clicked row
      expandedRowId = itemId;
      const item = mockWaitlist.find(i => i.id === itemId);
      if (!item) return;

      // Get buttons for this item's status
      const buttons = getButtonsForStatus(item.status);
      const buttonHTMLs = buttons.map(btnDef => generateButtonHTML(btnDef, item.id, item.name, true));
      const actionButtons = buttonHTMLs.join('\n');

      // Find the main row and insert mobile action row after it
      const mainRow = document.querySelector(`tr[data-item-id="${itemId}"]`);
      if (mainRow) {
        const mobileRow = document.createElement('tr');
        mobileRow.id = mobileActionRowId;
        mobileRow.className = 'mobile-action-row';
        mobileRow.innerHTML = `
          <td colspan="6" class="px-2 py-3">
            <div class="flex gap-1.5">
              ${actionButtons}
            </div>
          </td>
        `;
        
        // Insert after the main row
        mainRow.insertAdjacentElement('afterend', mobileRow);
        console.log(`MOBILE: Expanded row for item #${itemId}`);
      }
    }

    /**
     * For completed items (Check-In/Cancelled), returns object with completion time and duration.
     * For active items (Waiting/Called), shows current elapsed time from time_created.
     */
    function formatElapsedTime(item) {
      if (item.time_cleared) {
        // Completed items - return completion time and duration separately for two-line display
        const completionTime = new Date(item.time_cleared);
        const timeString = completionTime.toLocaleTimeString('en-GB', {
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });

        // Calculate duration
        const durationMs = item.time_cleared - item.time_created;
        const totalSeconds = Math.floor(durationMs / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        let durationString;
        if (minutes >= 60) {
          const hours = Math.floor(minutes / 60);
          const remainingMinutes = minutes % 60;
          if (remainingMinutes > 0) {
            durationString = `${hours} hr ${remainingMinutes} min`;
          } else {
            durationString = `${hours} hr`;
          }
        } else if (minutes > 0) {
          durationString = `${minutes} min`;
        } else {
          durationString = `${seconds} sec`;
        }

        return { time: timeString, duration: durationString, isTwoLine: true };
      } else {
        // Active items - calculate current elapsed time
        const elapsedMs = Date.now() - item.time_created;
        const totalSeconds = Math.floor(elapsedMs / 1000);

        let minutes = Math.floor(totalSeconds / 60);
        const seconds = String(totalSeconds % 60).padStart(2, '0');

        let displayString;
        if (minutes >= 60) {
          const hours = Math.floor(minutes / 60);
          const remainingMinutes = String(minutes % 60).padStart(2, '0');
          displayString = `${hours}:${remainingMinutes}:${seconds}`;
        } else {
          displayString = `${minutes}:${seconds}`;
        }

        return { time: displayString, duration: '', isTwoLine: false };
      }
    }

    /**
     * Returns the appropriate icon and CSS class based on the status string.
     */
    function getStatusIconAndClass(status) {
      let icon = '';
      let className = 'text-2xl font-bold';

      switch (status) {
        case 'Waiting':
        case 'Called':
          icon = '◎';
          className += ' status-waiting';
          break;
        case 'Check-In':
          icon = '✔';
          className += ' status-checkedin';
          break;
        case 'Cancelled':
          icon = '✗';
          className += ' status-cancelled';
          break;
        default:
          icon = '❔';
          className += ' text-gray-500';
      }
      return { icon, className };
    }

    /**
     * Displays a message box (replacing alert()).
     */
    function showMessageBox(message) {
      messageText.textContent = message;
      messageBox.classList.remove('hidden');
      messageBox.classList.add('flex');
    }

    /**
     * Closes the message box.
     */
    function closeMessageBox() {
      messageBox.classList.add('hidden');
      messageBox.classList.remove('flex');
    }

    /**
     * Adds a temporary highlight effect to a row.
     * The highlight appears briefly and then fades out.
     */
    function highlightRow(id) {
      requestAnimationFrame(() => {
        const rows = waitlistBody.getElementsByTagName('tr');
        const targetRow = Array.from(rows).find(row => {
          const idCell = row.querySelector('td:first-child');
          return idCell && idCell.textContent.trim() === id.toString();
        });

        if (targetRow) {
          // Store original background color
          const originalBgColor = targetRow.style.backgroundColor;
          
          // Add a temporary highlight class AND inline style for maximum priority
          targetRow.classList.add('button-click-highlight');
          targetRow.style.backgroundColor = '#334155';
          
          // Remove highlight after a moment
          setTimeout(() => {
            targetRow.classList.remove('button-click-highlight');
            targetRow.style.backgroundColor = originalBgColor;
          }, 500);
        }
      });
    }

    /**
     * Adds a temporary highlight effect to a button.
     */
    function highlightButton(buttonElement) {
      if (!buttonElement) return;
      
      const originalBgColor = buttonElement.style.backgroundColor;
      const originalColor = buttonElement.style.color;
      const originalBorderColor = buttonElement.style.borderColor;
      
      // Determine button color based on class
      let highlightBgColor = '#8b5cf6'; // default purple
      let highlightTextColor = '#ffffff';
      
      if (buttonElement.classList.contains('mobile-btn-call') || buttonElement.classList.contains('btn-call')) {
        highlightBgColor = '#34d399'; // green
      } else if (buttonElement.classList.contains('mobile-btn-ask') || buttonElement.classList.contains('btn-ask')) {
        highlightBgColor = '#60a5fa'; // blue
      } else if (buttonElement.classList.contains('mobile-btn-checkin') || buttonElement.classList.contains('btn-checkin')) {
        highlightBgColor = '#8b5cf6'; // purple
      } else if (buttonElement.classList.contains('mobile-btn-cancel') || buttonElement.classList.contains('btn-cancel')) {
        highlightBgColor = '#f87171'; // red
      }
      
      // Apply highlight
      buttonElement.style.backgroundColor = highlightBgColor;
      buttonElement.style.color = highlightTextColor;
      buttonElement.style.borderColor = highlightBgColor;
      
      // Remove highlight after a moment
      setTimeout(() => {
        buttonElement.style.backgroundColor = originalBgColor;
        buttonElement.style.color = originalColor;
        buttonElement.style.borderColor = originalBorderColor;
      }, 300);
    }

    /**
     * Handles customer actions. Updates status without changing buttons.
     */
    function handleCall(id, name, event) {
      console.log(`ACTION: Calling customer ${name} (#${id}).`);
      console.log(`INFO: [${name}, #${id}] 고객님께 전화를 겁니다.`);
      
      // Check if mobile (button highlight)
      const isMobile = window.innerWidth <= 768;
      
      if (isMobile && event && event.target) {
        // Highlight the button on mobile
        highlightButton(event.target);
      } else if (!isMobile) {
        // Desktop: Add row highlight
        highlightRow(id);
      }
      
      // Just update the status, don't change UI
      const item = mockWaitlist.find(item => item.id === id);
      if (item) {
        item.status = 'Called';
      }
    }

    function handleAsk(id, name, event) {
      console.log(`ACTION: Asking customer ${name} (#${id}).`);
      console.log(`INFO: [${name}, #${id}]에게 메시지/문의 창을 엽니다.`);
      
      // Check if mobile (button highlight)
      const isMobile = window.innerWidth <= 768;
      
      if (isMobile && event && event.target) {
        // Highlight the button on mobile
        highlightButton(event.target);
      } else {
        // Desktop: Add row highlight
        highlightRow(id);
      }
    }

    /**
     * Handles customer actions (Check-In). Updates initialScrollTop and performs scroll.
     */
    function handleCheckIn(id, name) {
      console.log(`ACTION: Checking in customer ${name} (#${id}).`);
      const item = mockWaitlist.find(item => item.id === id);
      let shouldScroll = false;

      if (item) {
        // Check if item was active before status change (Waiting or Called)
        const wasActive = item.status === 'Waiting' || item.status === 'Called';
        item.status = 'Check-In';
        item.time_cleared = Date.now(); // Set time_cleared when checking in

        if (wasActive && rowHeight > 0) {
          // 1. Update initialScrollTop by moving up one row's height to show the cleared item
          initialScrollTop -= rowHeight;
          console.log(`SCROLL_UPDATE: Check-In. Subtracting rowHeight (${rowHeight.toFixed(2)}px) from initialScrollTop.`);
          console.log(`SCROLL_UPDATE: New initialScrollTop: ${initialScrollTop.toFixed(2)}px`);
          shouldScroll = true;
        }
      }
      // Rerender after action to update the table structure and sort order
      renderWaitlist();

      // IMPORTANT FIX: Scroll must happen AFTER the DOM is updated by renderWaitlist.
      if (shouldScroll) {
        requestAnimationFrame(() => {
          // Find the position of the just completed item in the DOM
          const rows = waitlistBody.getElementsByTagName('tr');
          let targetScrollTop = 0;
          let itemFound = false;

          // Look for the row that contains the just completed item
          for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            const idCell = row.querySelector('td:first-child');
            if (idCell && idCell.textContent.trim() === id.toString()) {
              // Found the just completed item - scroll to show it at the top
              itemFound = true;
              break;
            }
            targetScrollTop += row.offsetHeight;
          }

          if (itemFound) {
            waitlistContainer.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
            console.log(`SCROLL_ACTION_RAF: Check-In scroll to show item #${id} at ${targetScrollTop.toFixed(2)}px`);
            initialScrollTop = targetScrollTop;

            // Add highlight effect to the completed item
            setTimeout(() => {
              const targetRow = Array.from(rows).find(row => {
                const idCell = row.querySelector('td:first-child');
                return idCell && idCell.textContent.trim() === id.toString();
              });

              if (targetRow) {
                targetRow.classList.add('checkin-highlight');
                console.log(`HIGHLIGHT: Added green highlight to Check-In item #${id}`);

                // Remove highlight after 1 second
                setTimeout(() => {
                  targetRow.classList.remove('checkin-highlight');
                  targetRow.classList.add('fade-out-highlight');

                  // Clean up fade-out class
                  setTimeout(() => {
                    targetRow.classList.remove('fade-out-highlight');
                  }, 700);
                }, 1000);
              }
            }, 300); // Small delay to ensure smooth scroll is started
          } else {
            console.log(`SCROLL_ACTION_RAF: Could not find item #${id} in DOM`);
          }
        });
      }
    }

    /**
     * Handles customer actions (Cancel). Updates initialScrollTop and performs scroll.
     */
    function handleCancel(id, name) {
      console.log(`ACTION: Cancelling customer ${name} (#${id}).`);
      const item = mockWaitlist.find(item => item.id === id);
      let shouldScroll = false;

      if (item) {
        // Check if item was active before status change (Waiting or Called)
        const wasActive = item.status === 'Waiting' || item.status === 'Called';
        item.status = 'Cancelled';
        item.time_cleared = Date.now(); // Set time_cleared when cancelling

        if (wasActive && rowHeight > 0) {
          // 1. Update initialScrollTop by moving up one row's height to show the cleared item
          initialScrollTop -= rowHeight;
          console.log(`SCROLL_UPDATE: Cancel. Subtracting rowHeight (${rowHeight.toFixed(2)}px) from initialScrollTop.`);
          console.log(`SCROLL_UPDATE: New initialScrollTop: ${initialScrollTop.toFixed(2)}px`);
          shouldScroll = true;
        }
      }
      // Rerender after action to update the table structure and sort order
      renderWaitlist();

      // IMPORTANT FIX: Scroll must happen AFTER the DOM is updated by renderWaitlist.
      if (shouldScroll) {
        requestAnimationFrame(() => {
          // Find the position of the just completed item in the DOM
          const rows = waitlistBody.getElementsByTagName('tr');
          let targetScrollTop = 0;
          let itemFound = false;

          // Look for the row that contains the just completed item
          for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            const idCell = row.querySelector('td:first-child');
            if (idCell && idCell.textContent.trim() === id.toString()) {
              // Found the just completed item - scroll to show it at the top
              itemFound = true;
              break;
            }
            targetScrollTop += row.offsetHeight;
          }

          if (itemFound) {
            waitlistContainer.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
            console.log(`SCROLL_ACTION_RAF: Cancel scroll to show item #${id} at ${targetScrollTop.toFixed(2)}px`);
            initialScrollTop = targetScrollTop;

            // Add highlight effect to the completed item
            setTimeout(() => {
              const targetRow = Array.from(rows).find(row => {
                const idCell = row.querySelector('td:first-child');
                return idCell && idCell.textContent.trim() === id.toString();
              });

              if (targetRow) {
                targetRow.classList.add('cancel-highlight');
                console.log(`HIGHLIGHT: Added red highlight to Cancel item #${id}`);

                // Remove highlight after 1 second
                setTimeout(() => {
                  targetRow.classList.remove('cancel-highlight');
                  targetRow.classList.add('fade-out-highlight');

                  // Clean up fade-out class
                  setTimeout(() => {
                    targetRow.classList.remove('fade-out-highlight');
                  }, 700);
                }, 1000);
              }
            }, 300); // Small delay to ensure smooth scroll is started
          } else {
            console.log(`SCROLL_ACTION_RAF: Could not find item #${id} in DOM`);
          }
        });
      }
    }

    /**
     * Handles Undo action for completed items (Check-In/Cancelled).
     * Restores the item to "Waiting" status with highlight effect.
     */
    function handleUndo(id, name) {
      console.log(`ACTION: Undo for customer ${name} (#${id}).`);
      const item = mockWaitlist.find(item => item.id === id);
      
      if (item && (item.status === 'Check-In' || item.status === 'Cancelled')) {
        const wasCompleted = true;
        item.status = 'Waiting';
        item.time_cleared = null; // Clear the completion time
        
        if (wasCompleted && rowHeight > 0) {
          // Adjust initialScrollTop when moving item from completed to active
          initialScrollTop += rowHeight;
          console.log(`SCROLL_UPDATE: Undo. Adding rowHeight (${rowHeight.toFixed(2)}px) to initialScrollTop.`);
          console.log(`SCROLL_UPDATE: New initialScrollTop: ${initialScrollTop.toFixed(2)}px`);
        }
      }
      
      renderWaitlist();
      
      // Add highlight effect to the restored item
      requestAnimationFrame(() => {
        const rows = waitlistBody.getElementsByTagName('tr');
        const targetRow = Array.from(rows).find(row => {
          const idCell = row.querySelector('td:first-child');
          return idCell && idCell.textContent.trim() === id.toString();
        });

        if (targetRow) {
          targetRow.classList.add('checkin-highlight'); // Reuse green highlight for Undo
          console.log(`HIGHLIGHT: Added green highlight to Undo item #${id}`);

          // Remove highlight after 1 second
          setTimeout(() => {
            targetRow.classList.remove('checkin-highlight');
            targetRow.classList.add('fade-out-highlight');

            // Clean up fade-out class
            setTimeout(() => {
              targetRow.classList.remove('fade-out-highlight');
            }, 700);
          }, 1000);
        }
      });
    }

    /**
     * Helper function to determine sorting priority.
     * Check-In and Cancelled should come first (lower number = higher priority).
     * @returns {number} The sort priority (0 for completed/cancelled, 1 for active).
     */
    function getSortPriority(status) {
      if (status === 'Check-In' || status === 'Cancelled') {
        return 0; // Highest priority (comes first)
      }
      return 1; // Lower priority (comes after 0)
    }

    /**
     * The core logic for determining scroll target, dynamic height, and button state.
     * 이 함수는 Active Queue 위치를 계산하고, 동적 높이 조절을 수행하며,
     * 스크롤 위치에 따라 버튼의 활성화/비활성화 상태를 결정합니다.
     * @returns {number} The scroll target position (total height of completed items).
     */
    function updateScrollAndButtonState() {
      //console.groupCollapsed("STATE_CHECK: Running updateScrollAndButtonState...");
      const rows = waitlistBody.getElementsByTagName('tr');
      if (!waitlistContainer || rows.length === 0 || !scrollButton) {
        console.log("STATE_CHECK: Pre-requisites missing. Exiting.");
        console.groupEnd();
        return 0;
      }

      // 1. Determine the height to scroll past (completed items)
      let totalHeightToScroll = 0;
      const completedItemsCount = mockWaitlist.filter(item => getSortPriority(item.status) === 0).length;
      const hasCompletedItems = completedItemsCount > 0;
      const totalRows = mockWaitlist.length;
      const shouldEnableScrolling = totalRows > displayedRows && hasCompletedItems;

      if (shouldEnableScrolling) {
        // Calculate height of completed rows (only if we should scroll)
        for (let i = 0; i < completedItemsCount && i < rows.length; i++) {
          totalHeightToScroll += rows[i].offsetHeight;
        }
      }

      /*
      console.log(`--- Scroll/Height Calculation ---`);
      console.log(`Total rows: ${totalRows}, displayedRows: ${displayedRows}, Completed items: ${completedItemsCount}`);
      console.log(`shouldEnableScrolling: ${shouldEnableScrolling}`);
      console.log(`Calculated scroll target (total height of completed items): ${totalHeightToScroll.toFixed(2)}px`);
      */

      // --- Dynamic Height/Scroll Activation ---
      if (shouldEnableScrolling) {
        // Force height to show exactly displayedRows number of rows
        //console.log(`HEIGHT: Forcing container height to show exactly ${displayedRows} rows.`);
        let displayedRowsHeight = 0;
        // Calculate height of exactly displayedRows number of rows
        for (let i = 0; i < Math.min(displayedRows, rows.length); i++) {
          displayedRowsHeight += rows[i].offsetHeight;
        }
        const headerHeight = waitlistContainer.querySelector('thead').offsetHeight;
        const forcedHeight = displayedRowsHeight + headerHeight + 5;

        //console.log(`HEIGHT: Setting forced height to ${forcedHeight.toFixed(2)}px (${displayedRows} rows + header)`);
        waitlistContainer.classList.remove(MAX_HEIGHT_CLASS);
        waitlistContainer.style.height = `${forcedHeight}px`;
      } else {
        // Revert to max-height setup when scrolling is not needed
        //console.log("HEIGHT: Reverting to max-height (no scrolling needed).");

        // DEBUG: Check if we should calculate exact height even when no scrolling needed
        if (totalRows === displayedRows) {
          let allRowsHeight = 0;
          for (let i = 0; i < rows.length; i++) {
            allRowsHeight += rows[i].offsetHeight;
          }
          const headerHeight = waitlistContainer.querySelector('thead').offsetHeight;
          const exactHeight = allRowsHeight + headerHeight + 10; // Extra padding for safety

          //console.log(`HEIGHT: Total rows equals displayedRows (${displayedRows}). Setting exact height to ${exactHeight.toFixed(2)}px`);
          waitlistContainer.classList.remove(MAX_HEIGHT_CLASS);
          waitlistContainer.style.height = `${exactHeight}px`;
        } else {
          waitlistContainer.classList.add(MAX_HEIGHT_CLASS);
          waitlistContainer.style.height = '';
        }
      }

      // Recalculate scroll state after potential height adjustments
      const isNowScrollable = waitlistContainer.scrollHeight > waitlistContainer.clientHeight;

      // Check if the current position is the Active Queue position (tolerance of 10px for browser precision)
      const isScrolledToActive = shouldEnableScrolling && totalHeightToScroll > 0 &&
        waitlistContainer.scrollTop >= (totalHeightToScroll - 10) &&
        waitlistContainer.scrollTop <= (totalHeightToScroll + 10);

      /*
      console.log(`--- Current Scroll State ---`);
      console.log(`isInitialScrollDone: ${isInitialScrollDone}`);
      console.log(`shouldEnableScrolling: ${shouldEnableScrolling}`);
      console.log(`isNowScrollable: ${isNowScrollable}`);
      console.log(`Current ScrollTop: ${waitlistContainer.scrollTop.toFixed(2)}px`);
      console.log(`initialScrollTop: ${initialScrollTop.toFixed(2)}px`);
      console.log(`isScrolledToActive: ${isScrolledToActive} (Is scroll position within +/- 10px of target)`);
      */

      // 2. Button State Update (Dynamic)

      if (!isInitialScrollDone) {
        // 초기 로드 시에는 비활성화 상태 유지
        //console.log(`--- BUTTON STATE DECISION ---`);
        //console.log("BUTTON: DISABLED. Reason: Initial setup (isInitialScrollDone=false).");
        scrollButton.disabled = true;
        scrollButton.textContent = "@ Active Queue";
        scrollButton.classList.remove('bg-yellow-600', 'text-slate-900', 'hover:bg-yellow-700', 'border-yellow-500');
        scrollButton.classList.add('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'border-slate-600');
        console.groupEnd();
        return totalHeightToScroll; // Early exit during initial setup
      }

      // isInitialScrollDone = true 일 때의 동적 로직:
      // 총 행 수가 minRowDisplay를 초과하고, Active Queue를 건너뛸 기록이 있고, 스크롤이 가능하며, 현재 Active Queue 위치에 있지 않은 경우 활성화
      const shouldEnableScrollDown = shouldEnableScrolling && isNowScrollable && !isScrolledToActive;

      //console.log(`--- BUTTON STATE DECISION (Dynamic) ---`);
      //console.log(`Should Enable? (shouldEnableScrolling && isScrollable && !isAtActive): ${shouldEnableScrollDown}`);


      if (shouldEnableScrollDown) {
        // ENABLED: User has manually scrolled away.
        //console.log(`BUTTON: ENABLED. Reason: Active history exists, scrollable, and user is not at the Active Queue.`);

        scrollButton.disabled = false;
        scrollButton.textContent = "Scroll to Active";
        scrollButton.classList.remove('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'border-slate-600');
        scrollButton.classList.add('bg-yellow-600', 'text-slate-900', 'hover:bg-yellow-700', 'border-yellow-500');
      } else {
        // DISABLED: At the active queue, no history, or not scrollable.

        scrollButton.disabled = true;

        // Display appropriate text for the disabled state
        if (isScrolledToActive) {
          //console.log(`BUTTON: DISABLED. Reason: Already at the Active Queue position.`);
          scrollButton.textContent = "@ Active Queue";
        } else if (!shouldEnableScrolling) {
          if (totalRows <= displayedRows) {
            //console.log(`BUTTON: DISABLED. Reason: Total rows (${totalRows}) <= displayedRows (${displayedRows}). All items visible.`);
            scrollButton.textContent = "Showing All";
          } else {
            //console.log(`BUTTON: DISABLED. Reason: No completed history to scroll past.`);
            scrollButton.textContent = "Scroll to Active";
          }
        } else if (!isNowScrollable) {
          //console.log(`BUTTON: DISABLED. Reason: Container is not scrollable (list is short).`);
          scrollButton.textContent = "Scroll to Active";
        } else {
          //console.log(`BUTTON: DISABLED. Reason: Default disabled state.`);
          scrollButton.textContent = "Scroll to Active";
        }

        scrollButton.classList.remove('bg-yellow-600', 'text-slate-900', 'hover:bg-yellow-700', 'border-yellow-500');
        scrollButton.classList.add('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'border-slate-600');
      }

      console.groupEnd(); // End STATE_CHECK group
      return totalHeightToScroll;
    }

    /**
     * Button click handler: Scrolls DOWN to the Active Queue instantly.
     */
    function handleScrollToActive() {
      console.log("ACTION: Scroll button clicked.");
      // 이제 scrollTarget은 initialScrollTop이 아니라, DOM을 기준으로 재계산된 정확한 값입니다.
      const totalHeightToScroll = updateScrollAndButtonState();

      // 버튼이 활성화된 상태일 때만 스크롤을 수행합니다.
      if (!scrollButton.disabled) {
        console.log(`SCROLL_ACTION: Performing scroll to ${totalHeightToScroll.toFixed(2)}px.`);
        // 'auto'를 사용하여 즉시 이동하고, 스크롤 이벤트 발생을 최소화합니다.
        waitlistContainer.scrollTo({ top: totalHeightToScroll, behavior: 'smooth' });

        // 스크롤 완료 후 버튼 상태를 즉시 업데이트하여 비활성화합니다.
        requestAnimationFrame(updateScrollAndButtonState);
      } else {
        console.log("SCROLL_ACTION: Scroll prevented, button is disabled.");
      }
    }


    /**
     * Renders the table based on the waitlist data. Called on initial load and on status change.
     */
    function renderWaitlist() {
      console.log("RENDER: Starting table render.");

      // Clean up mobile state on desktop
      if (window.innerWidth > 768) {
        document.querySelectorAll('.row-selected').forEach(row => {
          row.classList.remove('row-selected');
        });
        document.querySelectorAll('.mobile-action-row').forEach(row => {
          row.remove();
        });
        expandedRowId = null;
      }

      // 1. Sort the entire list: Completed items first (by time_cleared), then Active items by time_created (oldest first).
      mockWaitlist.sort((a, b) => {
        const priorityA = getSortPriority(a.status);
        const priorityB = getSortPriority(b.status);

        if (priorityA !== priorityB) {
          return priorityA - priorityB;
        }

        // Both items have the same priority level
        if (priorityA === 0) {
          // Both are completed items - sort by time_cleared (oldest first, recent last)
          return (a.time_cleared || 0) - (b.time_cleared || 0);
        } else {
          // Both are active items - sort by time_created (oldest first)
          return a.time_created - b.time_created;
        }
      });

      const completedItemsCount = mockWaitlist.filter(item => getSortPriority(item.status) === 0).length;
      console.log(`RENDER: Sorted list. Total items: ${mockWaitlist.length}, Completed items count: ${completedItemsCount}`);

      waitlistBody.innerHTML = ''; // Clear table content

      let tableHTML = '';
      mockWaitlist.forEach((item) => {
        const statusPriority = getSortPriority(item.status);
        const rowClass = statusPriority === 0 ? 'row-completed' : 'row-hover bg-slate-900';
        const statusData = getStatusIconAndClass(item.status);
        const timeData = formatElapsedTime(item);
        
        // Dynamic color classes based on item status
        const idClass = statusPriority === 0 ? 'text-slate-200' : 'text-amber-400';
        const nameClass = statusPriority === 0 ? 'text-slate-100' : 'text-amber-400';
        const paxClass = statusPriority === 0 ? 'text-slate-300' : 'text-amber-400';
        const timeClass = statusPriority === 0 ? 'text-slate-200' : 'text-amber-400';

        // Action Buttons - Generate using button definitions
        const buttons = getButtonsForStatus(item.status);
        const buttonHTMLs = buttons.map(btnDef => generateButtonHTML(btnDef, item.id, item.name, false));
        const actionButtons = buttonHTMLs.join('\n');
        const actionContainerClass = 'flex gap-1.5';

        // Build time cell HTML - two lines for completed items, one line for active items
        let timeHTML;
        if (timeData.isTwoLine) {
          timeHTML = `
            <div class="font-mono tracking-wider">${timeData.time}</div>
            <div class="text-xs font-mono">(${timeData.duration})</div>
          `;
        } else {
          timeHTML = `<div class="font-mono tracking-wider">${timeData.time}</div>`;
        }

        // Mobile: Add onclick handler, Desktop: no onclick
        // Always add onclick - the function itself checks if mobile
        const onclickAttr = `onclick="toggleMobileActions(${item.id}, event)"`;
        const rowClickableClass = 'row-clickable';

        tableHTML += `
                    <tr class="${rowClass} ${rowClickableClass}" data-item-id="${item.id}" ${onclickAttr}>
                        <td class="px-2 py-2 whitespace-nowrap text-sm font-medium ${idClass} text-center">${item.id}</td>
                        <td class="px-2 py-2 whitespace-nowrap text-sm">
                            <div class="font-semibold ${nameClass}">${item.name}</div>
                        </td>
                        <td class="px-2 py-2 whitespace-nowrap text-sm ${paxClass} font-bold text-center">${item.pax}</td>
                        <td id="time-${item.id}" class="px-2 py-2 whitespace-nowrap text-sm text-center ${timeClass}">
                            ${timeHTML}
                        </td>
                        <td class="action-column-cell px-2 py-2 whitespace-nowrap text-center text-sm font-medium">
                            <div class="${actionContainerClass}">
                                ${actionButtons}
                            </div>
                        </td>
                        <td class="px-2 py-2 whitespace-nowrap text-sm font-medium text-center">
                            <span class="${statusData.className}">${statusData.icon}</span>
                        </td>
                    </tr>
                 `;
      });

      waitlistBody.innerHTML = tableHTML;
      console.log("RENDER: Table HTML injected into DOM.");

      // Debug: Check for any row-selected classes on desktop
      if (window.innerWidth > 768) {
        // Force remove any inline styles or problematic classes
        const allRows = waitlistBody.querySelectorAll('tr');
        
        // Clean up mobile-related classes
        allRows.forEach((row) => {
          row.removeAttribute('style'); // Remove any inline styles
          row.classList.remove('row-selected'); // Remove row-selected if exists
        });
      }

      // Close any expanded mobile row when re-rendering
      expandedRowId = null;

      // NOTE: 데이터가 변경되어 렌더링이 발생하면, 버튼 상태와 스크롤 타겟을 즉시 업데이트합니다.
      updateScrollAndButtonState();
    }

    /**
     * Updates the elapsed time for all items every second.
     * Updates the HTML content of the time cell to support two-line display.
     */
    function updateElapsedTimes() {
      mockWaitlist.forEach(item => {
        const timeElement = document.getElementById(`time-${item.id}`);
        if (timeElement) {
          const timeData = formatElapsedTime(item);
          
          // Build time cell HTML - two lines for completed items, one line for active items
          let timeHTML;
          if (timeData.isTwoLine) {
            timeHTML = `
              <div class="font-mono tracking-wider">${timeData.time}</div>
              <div class="text-xs font-mono">(${timeData.duration})</div>
            `;
          } else {
            timeHTML = `<div class="font-mono tracking-wider">${timeData.time}</div>`;
          }
          
          timeElement.innerHTML = timeHTML;
        }
      });
    }

    // --- Initial Setup ---

    // 0. Clean up any stray mobile state classes on load
    document.querySelectorAll('.row-selected').forEach(row => {
      row.classList.remove('row-selected');
    });
    document.querySelectorAll('.mobile-action-row').forEach(row => {
      row.remove();
    });

    // 1. Initial rendering of the table content
    renderWaitlist(); // This now calls updateScrollAndButtonState() once

    // 2. Add scroll event listener. 
    // 사용자가 스크롤을 시작하면 버튼 상태가 동적으로 업데이트됩니다.
    waitlistContainer.addEventListener('scroll', updateScrollAndButtonState);

    // 3. Initial scroll setup: Set position and initial button state immediately after render.
    // requestAnimationFrame을 사용하여 DOM이 렌더링된 후 정확한 위치로 이동합니다.
    requestAnimationFrame(() => {
      console.log("INIT: DOM rendered. Starting initial scroll/state calculation.");

      // 1. 초기 스크롤 목표 위치를 계산하고 동적 높이 설정을 업데이트합니다.
      const scrollTarget = updateScrollAndButtonState();
      const completedItemsCount = mockWaitlist.filter(item => getSortPriority(item.status) === 0).length;

      const rows = waitlistBody.getElementsByTagName('tr');
      // NEW: Calculate row height based on a rendered row (must be done after render)
      if (rows.length > 0) {
        rowHeight = rows[0].offsetHeight;
        console.log(`INIT: Measured single rowHeight for update: ${rowHeight.toFixed(2)}px`);
      }

      console.log(`INIT: Calculated scrollTarget = ${scrollTarget.toFixed(2)}px. Completed items = ${completedItemsCount}`);

      // 2. 총 행 수가 displayedRows를 초과하고 완료된 항목이 있는 경우에만 초기 스크롤을 강제합니다.
      const totalRows = mockWaitlist.length;
      const shouldScrollToActive = totalRows > displayedRows && completedItemsCount > 0;
      console.log(`INIT: Total rows: ${totalRows}, displayedRows: ${displayedRows}, shouldScrollToActive: ${shouldScrollToActive}`);

      if (shouldScrollToActive) {
        // Disable hover temporarily during scroll
        waitlistContainer.classList.add('disable-hover');
        
        // 스크롤 위치를 즉시 설정합니다. (비헤이비어 'auto')
        waitlistContainer.scrollTop = scrollTarget;
        console.log(`INIT: Forced scroll to position: ${scrollTarget.toFixed(2)}px`);

        // Re-enable hover only when the user actually interacts (mousemove or window focus)
        const reenableHover = () => {
          waitlistContainer.classList.remove('disable-hover');
          console.log('INIT: Hover re-enabled after user interaction');
          document.removeEventListener('mousemove', reenableHover);
          window.removeEventListener('focus', reenableHover);
          clearTimeout(reenableFallback);
        };

        // If the user moves the mouse (or window gains focus), re-enable hover immediately
        document.addEventListener('mousemove', reenableHover, { once: true });
        window.addEventListener('focus', reenableHover, { once: true });

        // Fallback: if no interaction occurs within 8s, re-enable to avoid permanently disabling hover
        const reenableFallback = setTimeout(() => {
          waitlistContainer.classList.remove('disable-hover');
          console.log('INIT: Hover re-enabled by fallback after 8s');
          document.removeEventListener('mousemove', reenableHover);
          window.removeEventListener('focus', reenableHover);
        }, 8000);

        // 실제 스크롤된 위치를 다음 프레임에서 읽어서 정확한 값을 저장
        requestAnimationFrame(() => {
          // 더 정확한 스크롤을 위해 한 번 더 시도
          const actualScrollTop = waitlistContainer.scrollTop;
          if (Math.abs(actualScrollTop - scrollTarget) > 2) {
            console.log(`INIT: Adjusting scroll position. First attempt: ${actualScrollTop.toFixed(2)}px`);
            waitlistContainer.scrollTop = scrollTarget;

            // 조정 후 다시 한번 확인
            requestAnimationFrame(() => {
              initialScrollTop = waitlistContainer.scrollTop;
              console.log(`INIT: InitialScrollTop value recorded (final): ${initialScrollTop.toFixed(2)}px`);
              console.log(`INIT: Final difference: ${(scrollTarget - initialScrollTop).toFixed(2)}px`);
            });
          } else {
            initialScrollTop = actualScrollTop;
            console.log(`INIT: InitialScrollTop value recorded (actual): ${initialScrollTop.toFixed(2)}px`);
            console.log(`INIT: Difference between target and actual: ${(scrollTarget - initialScrollTop).toFixed(2)}px`);
          }
        });
      } else {
        initialScrollTop = 0; // Ensure it's 0 if no initial scroll occurred
        console.log("INIT: No completed items, skipping initial forced scroll.");
      }

      // 3. 스크롤 위치 설정 직후 버튼 상태를 업데이트하여 즉시 비활성화하고 텍스트를 변경합니다.
      updateScrollAndButtonState();
      console.log("INIT: Final button state check completed.");

      // 4. 초기 설정이 완료되었음을 플래그로 표시합니다. 
      isInitialScrollDone = true;
      console.log("INIT: isInitialScrollDone set to TRUE. Enabling dynamic button logic.");
    });

    // 4. Set up the non-rendering interval:
    // Updates elapsed times every second.
    setInterval(updateElapsedTimes, 1000);

    // 5. Add window resize listener: Scrollability and height calculations change on resize.
    // 창 크기가 변경될 때 버튼 상태를 업데이트합니다.
    window.addEventListener('resize', () => {
      updateScrollAndButtonState();
      
      // Clean up mobile state when switching to desktop
      if (window.innerWidth > 768) {
        // Remove all mobile action rows
        document.querySelectorAll('.mobile-action-row').forEach(row => row.remove());
        // Remove all row-selected classes
        document.querySelectorAll('.row-selected').forEach(row => {
          row.classList.remove('row-selected');
        });
        // Reset expanded row tracking
        expandedRowId = null;
        console.log('RESIZE: Switched to desktop, cleaned up mobile state');
      }
    });
  </script>
</body>

</html>